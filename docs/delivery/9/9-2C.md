# [9-2C] Remove Pagination Limits for Media Library Display

[Back to task list](./tasks.md)

## Description

Fix the 20-item pagination limit in the MediaTree component so users can select from their entire media library. Currently, the backend API defaults to `limit=20`, which prevents the tree from displaying the user's complete library. Since MediaTree already uses virtual scrolling for performance, it can efficiently handle thousands of items without pagination.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-29 00:00:00 | Created | N/A | Proposed | Task file created | AI_Agent |

## Requirements

### Functional Requirements

- MediaTree should display the user's entire media library (all items)
- Search functionality should work across all items, not just the first 20
- Tree hierarchy (Show > Season > Episode) should include all media
- No pagination controls needed (virtual scrolling handles performance)
- Support libraries with 1000+ items efficiently

### Technical Requirements

- **Backend** (`api/internal/api/media.go`):
  - Support `limit=-1` to fetch all items
  - Or raise max limit to 10000 for library browsing
  - Keep default at 20 for backward compatibility with other API consumers
  
- **Frontend** (`web/hooks/use-media.ts`):
  - Add `useMediaAll()` hook that fetches with `limit=-1`
  - Keep existing `useMedia()` hook for paginated use cases
  
- **Frontend** (`web/components/channel/channel-form.tsx`):
  - Use `useMediaAll()` instead of `useMedia()` for tree display
  
- **Performance**:
  - Leverage existing virtual scrolling in MediaTree
  - No UI lag with large libraries
  - Search remains fast

## Implementation Plan

### Step 1: Update Backend API Pagination Logic

**File**: `api/internal/api/media.go` (ListMedia function, ~line 168-179)

Update the limit parsing to support unlimited fetch:

```go
// Parse pagination parameters
limit := 20 // default
unlimitedFetch := false

if limitStr := c.Query("limit"); limitStr != "" {
    if l, err := strconv.Atoi(limitStr); err == nil {
        if l == -1 {
            // Special case: fetch all items
            unlimitedFetch = true
            limit = 0 // GORM uses 0 for no limit
        } else if l > 0 {
            limit = l
            if limit > 10000 {
                limit = 10000 // raised max limit for large libraries
            }
        }
    }
}
```

Update the response to reflect unlimited fetch:
```go
c.JSON(http.StatusOK, MediaListResponse{
    Items:  mediaItems,
    Total:  int(totalCount),
    Limit:  func() int { if unlimitedFetch { return int(totalCount) } else { return limit } }(),
    Offset: offset,
})
```

### Step 2: Add Frontend Hook for Unlimited Fetch

**File**: `web/hooks/use-media.ts` (after existing useMedia hook)

Add new hook for fetching entire library:

```typescript
// Fetch all media (for tree view/library browsing)
export function useMediaAll() {
  return useQuery({
    queryKey: mediaKeys.list({ limit: -1 }),
    queryFn: () => apiClient.getMedia({ limit: -1 }),
  });
}
```

### Step 3: Update ChannelForm to Use New Hook

**File**: `web/components/channel/channel-form.tsx` (~line 51)

Replace:
```typescript
const { data: mediaResponse, isLoading: isLoadingMedia } = useMedia();
```

With:
```typescript
const { data: mediaResponse, isLoading: isLoadingMedia } = useMediaAll();
```

Update import:
```typescript
import { useMediaAll } from "@/hooks/use-media";
```

### Step 4: Add Backend Tests

**File**: `api/internal/api/media_test.go`

Add test cases for unlimited fetch:

```go
t.Run("Fetch all media with limit=-1", func(t *testing.T) {
    // Create 25 media items (more than default limit of 20)
    for i := 0; i < 25; i++ {
        m := models.NewMedia(fmt.Sprintf("/test/video%d.mp4", i), fmt.Sprintf("Video %d", i), 1800)
        err := repos.Media.Create(context.Background(), m)
        require.NoError(t, err)
    }
    
    req := httptest.NewRequest("GET", "/api/media?limit=-1", nil)
    w := httptest.NewRecorder()
    
    router.ServeHTTP(w, req)
    
    assert.Equal(t, http.StatusOK, w.Code)
    
    var resp MediaListResponse
    err := json.Unmarshal(w.Body.Bytes(), &resp)
    require.NoError(t, err)
    assert.GreaterOrEqual(t, len(resp.Items), 25, "Should return all items")
    assert.Equal(t, resp.Total, len(resp.Items), "Limit should equal total when fetching all")
})

t.Run("Raised maximum limit to 10000", func(t *testing.T) {
    req := httptest.NewRequest("GET", "/api/media?limit=10000", nil)
    w := httptest.NewRecorder()
    
    router.ServeHTTP(w, req)
    
    assert.Equal(t, http.StatusOK, w.Code)
    
    var resp MediaListResponse
    err := json.Unmarshal(w.Body.Bytes(), &resp)
    require.NoError(t, err)
    assert.Equal(t, 10000, resp.Limit, "Should accept 10000 as limit")
})
```

### Step 5: Verify Performance with Large Library

Manual testing with different library sizes:
- Small (< 20 items): Verify all visible
- Medium (50-100 items): Verify all visible, smooth scrolling
- Large (200-500 items): Verify virtual scrolling performance
- Very large (1000+ items): Verify no lag, search works

## Test Plan

### Objective
Verify that removing pagination limits allows MediaTree to display the complete media library while maintaining good performance through virtual scrolling.

### Test Scope
- Backend API unlimited fetch
- Frontend hook integration
- MediaTree performance with large libraries
- Search functionality across all items
- Tree hierarchy integrity

### Environment & Setup
- Backend: Go API with test database
- Frontend: React with MediaTree component
- Test data: Libraries with 20, 100, 500, 1000+ items

### Key Test Scenarios

#### Backend API Tests (Automated)
1. **Unlimited Fetch**: `GET /api/media?limit=-1` returns all items
2. **Raised Max Limit**: `GET /api/media?limit=10000` accepted
3. **Default Behavior**: `GET /api/media` still returns 20 items (backward compatibility)
4. **With Show Filter**: `GET /api/media?limit=-1&show=TestShow` returns all items for show

#### Frontend Integration Tests (Manual)
1. **Small Library (< 20 items)**:
   - All items visible in tree
   - No duplicate fetching
   
2. **Medium Library (50-100 items)**:
   - All items visible in tree
   - Tree hierarchy correct (Shows > Seasons > Episodes)
   - Selection works for all items
   
3. **Large Library (200-500 items)**:
   - All items load
   - Virtual scrolling smooth
   - No lag when expanding/collapsing nodes
   - Search filters across all items
   
4. **Very Large Library (1000+ items)**:
   - Initial load time acceptable (< 3 seconds)
   - Virtual scrolling maintains 60fps
   - Search results instant
   - Selection operations fast
   
5. **"Show Only Added" Filter**:
   - Works with full library loaded
   - Toggle is responsive
   - Filtered tree maintains hierarchy

#### Edge Cases
1. Empty library (0 items)
2. Single item library
3. Library with one show, 1000 episodes
4. Library with 100 shows, 10 episodes each

### Success Criteria
- Backend tests pass with 100% success rate
- All library sizes display completely
- No performance degradation with virtual scrolling
- Search works across entire library
- No regressions in tree functionality (selection, filtering, hierarchy)

## Verification

### Backend
- [ ] API supports `limit=-1` for unlimited fetch
- [ ] Max limit raised to 10000
- [ ] Default limit remains 20 (backward compatibility)
- [ ] Response includes correct total and limit values
- [ ] All backend tests pass

### Frontend
- [ ] `useMediaAll()` hook created and exported
- [ ] ChannelForm uses `useMediaAll()` instead of `useMedia()`
- [ ] Import statements updated
- [ ] TypeScript compilation passes

### Integration
- [ ] MediaTree displays all items from library
- [ ] Search works across all items
- [ ] Tree hierarchy includes all media
- [ ] "Show Only Added" filter works with full library
- [ ] Selection operations work with all items

### Performance
- [ ] Virtual scrolling handles 1000+ items smoothly
- [ ] No lag when scrolling through large libraries
- [ ] Search remains fast with large datasets
- [ ] Initial load time acceptable (< 3 seconds for 1000 items)

### Testing
- [ ] Backend tests added and passing
- [ ] Manual testing completed for all library sizes
- [ ] No regressions in existing functionality

## Files Modified

### Backend
- `api/internal/api/media.go` - Update pagination logic to support unlimited fetch
- `api/internal/api/media_test.go` - Add tests for unlimited fetch and raised limit

### Frontend
- `web/hooks/use-media.ts` - Add `useMediaAll()` hook
- `web/components/channel/channel-form.tsx` - Use `useMediaAll()` instead of `useMedia()`

### API Specs (if needed)
- `docs/api-specs/media/media-api.md` - Document unlimited fetch capability

## Dependencies

- **MediaTree Component**: Already supports virtual scrolling for performance
- **Backend DB Repository**: Already supports unlimited queries (limit=0 in GORM)
- **API Client**: Already supports passing limit parameter

## Notes

### Why Not Keep Pagination?

MediaTree is designed as a hierarchical browser, not a paginated list. Pagination would break:
- Tree structure (can't split shows/seasons across pages)
- Search functionality (can only search visible items)
- Selection logic (can't select items not loaded)

### Performance Considerations

Virtual scrolling makes this approach viable:
- Only renders visible rows (~20-30 at a time)
- Handles 10,000+ items efficiently
- Used by VS Code, Slack, and other apps with large lists

### Alternative Approaches Considered

1. **Infinite Scroll**: Complex with tree structure, bad UX
2. **Load on Expand**: Requires many API calls, slow
3. **Server-side Tree**: Complex, doesn't solve search problem
4. **Keep Pagination**: Breaks tree/search functionality

**Chosen approach**: Load all, use virtual scrolling for performance.

