# [2-4] Build Async Media Scanner

[Back to task list](./tasks.md)

## Description

Implement an asynchronous media scanner that recursively scans a directory for video files, extracts metadata using FFprobe, parses filenames for organization, validates files, and stores results in the database. The scanner runs in the background with progress tracking accessible via API.

This is a core component that ties together FFprobe, filename parser, validator, and database operations to populate the media library.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-27 00:50:00 | Created | N/A | Proposed | Task file created | AI_Agent |
| 2025-10-27 14:25:00 | Status Change | Proposed | InProgress | Implementation started | AI_Agent |
| 2025-10-27 14:50:00 | Status Change | InProgress | Review | Implementation completed, tests passing | AI_Agent |
| 2025-10-27 15:30:00 | Status Change | Review | Done | All race conditions fixed, tests passing, ready for production | AI_Agent |

## Requirements

### Functional Requirements
- Recursively scan directory for video files
- Support formats: MP4, MKV, AVI, MOV
- Extract metadata using FFprobe for each file
- Parse filename for show/season/episode
- Validate codec compatibility
- Store/update media in database
- Track progress (files processed, total files, errors)
- Run asynchronously in background
- Handle scan cancellation
- Skip non-video files
- Handle errors gracefully (corrupted files, permission issues)
- Prevent multiple concurrent scans

### Technical Requirements
- Use goroutines for async execution
- Context support for cancellation
- Thread-safe progress tracking (sync.RWMutex)
- Generate unique scan ID (UUID)
- Store scan state in memory (map of active scans)
- Use filepath.Walk for directory traversal
- Integrate FFprobe, parser, validator packages
- Use Media repository for database operations
- Structured logging with zerolog

### Progress Tracking
- Total files found
- Files processed
- Files succeeded
- Files failed
- Current file being processed
- Status (running, completed, cancelled, failed)
- Start time
- End time
- Error messages

## Implementation Plan

### Step 1: Define Data Structures
```go
type ScanStatus string
const (
    ScanStatusRunning   ScanStatus = "running"
    ScanStatusCompleted ScanStatus = "completed"
    ScanStatusCancelled ScanStatus = "cancelled"
    ScanStatusFailed    ScanStatus = "failed"
)

type ScanProgress struct {
    ScanID          string
    Status          ScanStatus
    TotalFiles      int
    ProcessedFiles  int
    SuccessCount    int
    FailedCount     int
    CurrentFile     string
    StartTime       time.Time
    EndTime         *time.Time
    Errors          []string
    mu              sync.RWMutex
}

type Scanner struct {
    db            *db.DB
    activeScans   map[string]*ScanProgress
    mu            sync.RWMutex
}
```

### Step 2: Implement Scanner Initialization
- Create NewScanner() constructor
- Initialize activeScans map
- Store database reference

### Step 3: Implement Directory Walking
- Use filepath.Walk to traverse directory
- Filter by supported extensions (.mp4, .mkv, .avi, .mov)
- Count total files first pass
- Process each file in second pass
- Handle permission errors gracefully

### Step 4: Implement File Processing
- Call FFprobe to extract metadata
- Call parser to extract show/season/episode
- Call validator to check compatibility
- Create/update Media model
- Save to database using repository
- Update progress
- Log errors but continue processing

### Step 5: Implement Progress Tracking
- Thread-safe progress updates
- GetProgress() method to retrieve status
- Store active scans in memory map
- Clean up completed scans after retrieval

### Step 6: Implement Scan Lifecycle
- StartScan() - initiates async scan, returns scan ID
- GetScanProgress() - retrieves progress by ID
- CancelScan() - cancels running scan via context
- Cleanup - remove completed scans from memory

### Step 7: Integration
- Connect to Media repository
- Use existing FFprobe, parser, validator packages
- Proper error handling and logging

### Step 8: Unit Tests
- Test directory walking
- Test file filtering
- Test progress tracking
- Test concurrent scan prevention
- Test cancellation

## Test Plan

### Objective
Verify scanner correctly processes video files and tracks progress.

### Test Scope
- Directory traversal and file filtering
- FFprobe integration
- Parser integration
- Validator integration
- Database operations
- Progress tracking
- Async execution
- Error handling

### Key Test Scenarios

1. **Successful Scan**
   - Given: Directory with valid video files
   - When: StartScan() called
   - Then: All files processed, metadata stored, progress=100%

2. **Mixed Files**
   - Given: Directory with videos and non-videos
   - When: StartScan() called
   - Then: Only video files processed, others skipped

3. **Corrupted File Handling**
   - Given: Directory with corrupted video file
   - When: StartScan() called
   - Then: Error logged, scan continues, failed count incremented

4. **Progress Tracking**
   - Given: Scan in progress
   - When: GetScanProgress() called
   - Then: Returns current progress with accurate counts

5. **Scan Cancellation**
   - Given: Long-running scan
   - When: CancelScan() called
   - Then: Scan stops, status=cancelled

6. **Concurrent Scan Prevention**
   - Given: Scan already running
   - When: StartScan() called again
   - Then: Returns error or queues scan

7. **Database Updates**
   - Given: File already in database
   - When: File scanned again
   - Then: Database record updated, not duplicated

### Success Criteria
- All video files found and processed
- Progress accurately tracked
- Errors don't stop entire scan
- Database correctly populated
- Async operation doesn't block
- Memory cleaned up after completion

## Verification

### Acceptance Criteria
- [x] Scanner package created in `internal/media/scanner.go`
- [x] Data structures defined (ScanProgress, Scanner)
- [x] StartScan() initiates async scan
- [x] GetScanProgress() returns accurate progress
- [x] Integrates FFprobe, parser, validator
- [x] Saves media to database
- [x] Handles errors gracefully
- [x] Thread-safe progress tracking
- [x] Context support for cancellation
- [x] Supports MP4, MKV, AVI, MOV
- [x] Unit tests cover key scenarios
- [x] Integration tests with real files

### Definition of Done
- [x] All acceptance criteria met
- [x] Unit tests pass (18 tests, all passing)
- [x] Integration tests pass (database operations verified)
- [x] Code follows Go best practices
- [x] No linter errors (golangci-lint clean)
- [x] No race conditions (verified with -race flag)

### Test Results
```
go test -race ./internal/media/... -timeout 60s
ok      github.com/stwalsh4118/hermes/internal/media    1.616s
```

All 18 scanner tests pass with race detector enabled, confirming thread safety.

## Files Modified

### New Files Created
- `api/internal/media/scanner.go` - Media scanner implementation (410 lines)
- `api/internal/media/scanner_test.go` - Comprehensive unit tests (477 lines, 18 test cases)

### Files Modified
- None (new package)

### API Specifications Updated
- None - scanner is internal package, API endpoints will be added in task 2-5

## Notes

### Implementation Details
- ✅ Scanner prevents concurrent scans via mutex check before starting
- ✅ Progress remains in memory after scan completes for retrieval
- ✅ Large directories supported via two-pass approach (count, then process)
- ✅ Scan ID returned immediately for async progress tracking
- ✅ **Duplicate files handled via optimistic insert pattern (TOCTOU race fixed)**
- ✅ Each file processed in sequence with comprehensive error handling
- ✅ Context cancellation support throughout scanning pipeline
- ✅ **Automatic cleanup of old scans to prevent memory leak**
- ✅ **Background cleanup goroutine with configurable retention period**

### Performance Characteristics
- Two-pass directory walk: first counts files, second processes
- Sequential file processing (can be parallelized in future if needed)
- **Optimistic insert for database upsert (attempt create first, update on conflict)**
- **Automatic cleanup runs every 15 minutes, removes scans older than 1 hour**
- Memory usage: O(n) for file list, O(active scans) bounded by cleanup

### Thread Safety
- All progress updates protected by sync.RWMutex
- GetScanProgress() returns deep copy to prevent external mutations
- Concurrent progress reads tested and verified with -race flag
- Scanner.activeScans map protected by Scanner.mu
- **Cleanup goroutine safely coordinates with scanner operations**
- **Scanner.Stop() provides graceful shutdown of background goroutine**

### Future Enhancements
- Add scan queue for multiple concurrent scan requests
- Implement batch database inserts for better performance
- Add configurable timeout per file
- Support scan resume/restart
- Add progress webhooks/callbacks
- Make cleanup interval and retention period configurable

### Bug Fixes Applied (Post-Review)
- **Fixed TOCTOU race condition in upsertMedia**: Changed from GetByPath → Create/Update pattern to optimistic insert (Create first, Update on conflict). This eliminates the race window where another process could create the same file between the check and insert operations.
- **Fixed memory leak in activeScans**: Added automatic cleanup mechanism that removes completed/cancelled/failed scans after a retention period (1 hour by default). Background goroutine runs cleanup every 15 minutes. Scanner.Stop() method provides graceful shutdown.
- **Fixed race condition in concurrent scan prevention**: Changed from RLock (check) + Lock (insert) to single Lock for atomic check-and-insert operation. Previously, multiple goroutines could pass the concurrent scan check simultaneously because the RLock was released before the write Lock was acquired. Now the check and insert are atomic within a single Lock/Unlock pair, ensuring only one scan can be running at a time.
- **Added comprehensive tests**: 9 new test cases covering the optimistic insert pattern, cleanup functionality, graceful shutdown, and concurrent scan prevention race conditions.

