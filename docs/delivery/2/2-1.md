# [2-1] Implement FFprobe Integration

[Back to task list](./tasks.md)

## Description

Create a Go package that wraps FFprobe to extract video file metadata. This is the foundational component for media scanning, providing essential information about video files including duration, codecs, resolution, and file size.

FFprobe will be executed as an external command with JSON output format, and the results will be parsed into Go structures. Error handling will account for corrupted files, unsupported formats, and missing FFprobe installation.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-27 00:00:00 | Created | N/A | Proposed | Task file created | AI_Agent |
| 2025-10-27 00:05:00 | Status Change | Proposed | Agreed | Task approved for implementation | User |
| 2025-10-27 00:06:00 | Status Change | Agreed | InProgress | Started implementation | AI_Agent |
| 2025-10-27 00:30:00 | Status Change | InProgress | Review | Implementation completed, tests passing | AI_Agent |
| 2025-10-27 01:30:00 | Status Change | Review | Done | Task approved and completed | User |

## Requirements

### Functional Requirements
- Execute FFprobe with JSON output format
- Parse video stream metadata (codec, resolution, duration)
- Parse audio stream metadata (codec, channels, sample rate)
- Extract file-level metadata (size, format, bitrate)
- Handle multiple audio/video streams (select primary streams)
- Return structured Go data
- Support formats: MP4, MKV, AVI, MOV

### Technical Requirements
- Use `os/exec` to run FFprobe
- Parse JSON output using `encoding/json`
- Timeout protection (30 seconds max per file)
- Context support for cancellation
- Structured logging with zerolog
- Error types for different failure scenarios

### Error Scenarios to Handle
- FFprobe not installed
- File not found or not readable
- Corrupted/invalid video file
- Unsupported format
- Command timeout
- JSON parsing errors

## Implementation Plan

### Step 1: Define Data Structures
Create structures to represent FFprobe JSON output:
- `FFprobeResult` - Top-level result with streams and format
- `Stream` - Individual stream data (video/audio)
- `Format` - File format information
- `VideoMetadata` - Simplified output for application use

### Step 2: Implement FFprobe Command Execution
- Build command: `ffprobe -v quiet -print_format json -show_format -show_streams <file>`
- Execute with context and timeout
- Capture stdout and stderr
- Handle execution errors

### Step 3: Implement JSON Parsing
- Parse FFprobe JSON output into structures
- Extract video stream (prefer first video stream)
- Extract audio stream (prefer first audio stream)
- Handle missing streams gracefully

### Step 4: Implement Metadata Extraction
- Convert FFprobe data to simplified `VideoMetadata` structure
- Calculate duration in seconds (int64)
- Format resolution as "WxH" string
- Extract file size from format section
- Map codec names to standard forms (e.g., "h264", "aac")

### Step 5: Error Handling and Logging
- Check FFprobe installation at package init
- Return typed errors for different failure scenarios
- Log all operations with context
- Include file path in all log messages

### Step 6: Unit Tests
- Test successful metadata extraction
- Test various video formats
- Test error scenarios (mock FFprobe failures)
- Test timeout handling
- Test malformed JSON

## Test Plan

### Objective
Verify FFprobe integration correctly extracts metadata from video files and handles errors appropriately.

### Test Scope
- FFprobe execution and JSON parsing
- Metadata extraction accuracy
- Error handling for various failure modes
- Timeout protection

### Key Test Scenarios

1. **Successful Metadata Extraction**
   - Given: Valid MP4 file with H.264 video and AAC audio
   - When: ProbeFile() is called
   - Then: Returns complete metadata (duration, codecs, resolution, size)

2. **Multiple Stream Handling**
   - Given: MKV file with multiple audio tracks
   - When: ProbeFile() is called
   - Then: Returns first video and first audio stream metadata

3. **Missing Streams**
   - Given: Audio-only file
   - When: ProbeFile() is called
   - Then: Returns audio metadata, video fields empty/nil

4. **File Not Found**
   - Given: Non-existent file path
   - When: ProbeFile() is called
   - Then: Returns ErrFileNotFound

5. **Corrupted File**
   - Given: Corrupted/invalid video file
   - When: ProbeFile() is called
   - Then: Returns ErrInvalidFile with FFprobe error details

6. **Timeout Protection**
   - Given: Context with short timeout
   - When: ProbeFile() takes too long
   - Then: Returns context.DeadlineExceeded error

7. **FFprobe Not Installed**
   - Given: FFprobe command not in PATH
   - When: ProbeFile() is called
   - Then: Returns ErrFFprobeNotFound

### Success Criteria
- All unit tests pass
- Correctly extracts metadata from sample files
- Error handling covers all failure scenarios
- Execution times out after 30 seconds
- Logging provides useful diagnostic information

## Verification

### Acceptance Criteria
- [x] FFprobe package created in `internal/media/ffprobe.go`
- [x] Data structures defined for FFprobe JSON output
- [x] ProbeFile() function executes FFprobe and parses results
- [x] Returns duration, video codec, audio codec, resolution, file size
- [x] Context support with timeout protection
- [x] Typed errors for different failure scenarios
- [x] Unit tests cover success and error cases
- [x] Logging integrated with zerolog
- [x] Documentation includes usage examples

### Definition of Done
- All acceptance criteria met
- Unit tests pass with >80% code coverage
- Code follows Go best practices
- No linter errors
- Error messages are actionable

## Files Modified

### New Files Created
- `api/internal/media/ffprobe.go` - FFprobe wrapper implementation
- `api/internal/media/ffprobe_test.go` - Unit tests

### Files Modified
- None (new package)

## Notes

- FFprobe must be installed on the system (part of FFmpeg package)
- Command format: `ffprobe -v quiet -print_format json -show_format -show_streams <file>`
- Duration may be in streams or format section (check both)
- Some formats store duration as string, others as float
- Resolution calculated from width/height in video stream
- Bitrate may be at stream level or format level

