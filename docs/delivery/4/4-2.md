# [4-2] Implement Core Timeline Calculator

[Back to task list](./tasks.md)

## Description

Implement the pure mathematical algorithm that calculates the current timeline position for a channel. This is a stateless, testable function that takes channel properties and playlist data as input and returns the current playback position. The calculator must handle all edge cases and meet performance requirements (<100ms for 1000-item playlists).

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-30 00:00:00 | Created | N/A | Proposed | Task file created | AI_Agent |
| 2025-10-30 00:07:00 | Status Change | Proposed | Agreed | Task approved | User |
| 2025-10-30 00:08:00 | Status Change | Agreed | InProgress | Starting calculator implementation | AI_Agent |
| 2025-10-30 00:20:00 | Status Change | InProgress | Review | Calculator implemented with all tests passing and benchmarks met | AI_Agent |
| 2025-10-30 00:21:00 | Status Change | Review | Done | Task approved | User |

## Requirements

### Functional Requirements
- Calculate elapsed time since channel start
- Calculate total playlist duration by summing item durations
- Apply modulo operation for looping playlists
- Find which playlist item contains the current position
- Calculate offset within that item
- Return complete `TimelinePosition` with all fields
- Handle all edge cases per PRD

### Edge Cases to Handle
1. **Empty Playlist** - Return error
2. **Time Before Start** - Return "not started" error
3. **Non-looping Past End** - Return "finished" error
4. **Single Item Playlist** - Works with loop on/off
5. **Loop Boundary** - Correctly wraps to first item
6. **Very Long Playlists** - Efficient O(n) traversal

### Performance Requirements
- Must complete in < 100ms for playlists up to 1000 items
- Use integer arithmetic (seconds, not nanoseconds)
- Avoid unnecessary allocations
- Single-pass playlist traversal

### Algorithm (from PRD)
```
elapsed = currentTime - startTime

if elapsed < 0:
    return "channel not started yet"

totalPlaylistDuration = sum(item.duration for item in playlist)

if totalPlaylistDuration == 0:
    return "empty playlist"

if loop:
    position = elapsed % totalPlaylistDuration
else:
    if elapsed >= totalPlaylistDuration:
        return "playlist finished"
    position = elapsed

# Find which item contains this position
accumulated = 0
for item in playlist:
    if position < accumulated + item.duration:
        offsetInItem = position - accumulated
        return (item, offsetInItem)
    accumulated += item.duration
```

## Implementation Plan

### Step 1: Create calculator.go
- Create `api/internal/timeline/calculator.go`
- Define main calculation function signature

### Step 2: Implement input validation
- Check for empty playlist
- Check for time before start
- Check for zero playlist duration

### Step 3: Implement elapsed time calculation
- Calculate duration since channel start
- Handle UTC time correctly
- Convert to seconds (int64)

### Step 4: Implement total duration calculation
- Sum all playlist item durations
- Handle potential overflow (unlikely but possible)

### Step 5: Implement position calculation
- Apply loop logic (modulo for looping channels)
- Check for past-end on non-looping channels

### Step 6: Implement item finder
- Single-pass linear search
- Track accumulated duration
- Find item containing current position
- Calculate offset within item

### Step 7: Build TimelinePosition result
- Populate all fields
- Calculate StartedAt (currentTime - offsetInItem)
- Calculate EndsAt (StartedAt + item.Duration)

### Step 8: Comprehensive unit tests
- Test all edge cases listed in PRD
- Test loop boundaries
- Test various playlist sizes
- Test accuracy (±1 second)
- Benchmark performance with large playlists

## Test Plan

### Objective
Verify calculator produces accurate results for all scenarios and meets performance requirements.

### Test Scope
- All edge cases from PRD
- Accuracy verification
- Performance benchmarks

### Key Test Scenarios

1. **Normal Operation - Mid Playlist**
   - Given: Channel started 2 hours ago, 3 items (1h each), currently in item 2
   - Then: Returns item 2 with correct offset

2. **First Item**
   - Given: Channel just started
   - Then: Returns first item with offset 0

3. **Last Item**
   - Given: Non-looping channel near end
   - Then: Returns last item with correct offset

4. **Loop Boundary Crossing**
   - Given: Looping channel, elapsed time > total duration
   - Then: Wraps correctly to beginning

5. **Non-Loop Past End**
   - Given: Non-looping channel, elapsed time > total duration
   - Then: Returns "finished" error

6. **Empty Playlist**
   - Given: Playlist with no items
   - Then: Returns "empty playlist" error

7. **Time Before Start**
   - Given: Current time < channel start time
   - Then: Returns "not started" error

8. **Single Item Playlist - Looping**
   - Given: One item, loop enabled, elapsed > duration
   - Then: Returns item with correct wrapped offset

9. **Single Item Playlist - Non-Looping**
   - Given: One item, loop disabled, elapsed > duration
   - Then: Returns "finished" error

10. **Accuracy Test**
    - Given: Various timestamps
    - Then: Position accurate to ±1 second

11. **Performance Benchmark**
    - Given: Playlist with 1000 items
    - Then: Calculation completes in < 100ms

### Success Criteria
- All unit tests pass
- Accuracy within ±1 second
- Performance < 100ms for 1000-item playlist
- Code coverage > 90%

## Verification

### Acceptance Criteria
- [ ] Calculator function implemented
- [ ] Handles all edge cases correctly
- [ ] Returns complete TimelinePosition with all fields
- [ ] Accuracy within ±1 second
- [ ] Performance < 100ms for 1000 items
- [ ] Unit tests cover all scenarios
- [ ] Benchmark tests demonstrate performance
- [ ] No linter errors

### Definition of Done
- All acceptance criteria met
- Unit tests pass
- Benchmark results documented
- Code follows Go best practices
- Ready for integration with service layer

## Files Modified

### New Files Created
- `api/internal/timeline/calculator.go` - Core calculation algorithm
- `api/internal/timeline/calculator_test.go` - Comprehensive unit and benchmark tests

### API Specifications Updated
- `docs/api-specs/timeline/timeline-api.md` - Document calculator interface

## Notes

- This is pure business logic with no I/O or database access
- Makes testing easy and fast
- Service layer will fetch data and call this calculator
- Use UTC time throughout to avoid timezone issues
- Integer seconds avoid floating-point precision issues
- Performance is critical - this may be called frequently

