# [1-7] Implement Database Layer

[Back to task list](./tasks.md)

## Description

Implement the database access layer using the repository pattern with GORM ORM. This includes connection management, CRUD operations for all models, transaction support, and proper error handling. The implementation uses GORM with the SQLite driver and provides a clean abstraction for data access while maintaining golang-migrate for schema management.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-26 12:00:00 | Created | N/A | Proposed | Task file created | AI_Agent |
| 2025-10-27 00:00:00 | Status Change | Proposed | Agreed | Task approved for implementation | User |
| 2025-10-27 00:05:00 | Status Change | Agreed | InProgress | Started implementation with GORM | AI_Agent |
| 2025-10-27 00:30:00 | Status Change | InProgress | Review | GORM implementation complete, all repositories and documentation updated | AI_Agent |
| 2025-10-27 00:45:00 | Status Change | Review | Done | Code review issues fixed, task approved and completed | User |

## Requirements

### Functional Requirements
- Database connection management with pooling
- Repository interface for each model
- CRUD operations: Create, Read (by ID, List), Update, Delete
- Transaction support for multi-operation consistency
- Proper error handling and wrapping
- Connection health check
- Automatic UUID generation on create
- Timestamp management (created_at, updated_at)

### Repository Operations

**Channel Repository:**
- Create(channel) - Insert new channel
- GetByID(id) - Get channel by UUID
- List() - Get all channels
- Update(channel) - Update existing channel
- Delete(id) - Delete channel (cascade to playlist items)
- GetWithPlaylist(id) - Get channel with playlist items

**Media Repository:**
- Create(media) - Insert new media
- GetByID(id) - Get media by UUID
- GetByPath(path) - Get media by file path
- List() - Get all media with pagination
- ListByShow(showName) - Get media filtered by show
- Update(media) - Update media metadata
- Delete(id) - Delete media

**PlaylistItem Repository:**
- Create(item) - Insert playlist item
- GetByChannelID(channelID) - Get all items for channel, ordered by position
- GetByID(id) - Get single playlist item
- Delete(id) - Delete playlist item
- DeleteByChannelID(channelID) - Delete all items for channel
- Reorder(channelID, items) - Update positions for reordering
- GetWithMedia(channelID) - Get playlist items with joined media

**Settings Repository:**
- Get() - Get settings (always returns single row)
- Update(settings) - Update settings

### Technical Requirements
- Use GORM ORM (gorm.io/gorm)
- SQLite driver: gorm.io/driver/sqlite
- GORM automatically uses parameterized queries (prevents SQL injection)
- Return custom error types for not found, constraint violations
- Use context for cancellation support via WithContext
- Enable foreign key constraints on connection
- Enable WAL mode for better concurrency
- Connection pooling configuration
- Schema managed by golang-migrate (not GORM auto-migrate)

## Implementation Plan

### Step 1: Create Database Package Structure
```
internal/db/
├── db.go              # GORM connection management
├── errors.go          # Custom error types
├── migrations.go      # Migration runner (from task 1-5)
├── transaction.go     # Transaction support
├── channel.go         # Channel repository
├── media.go           # Media repository
├── playlist.go        # PlaylistItem repository
├── settings.go        # Settings repository
└── repositories.go    # Repository factory
```

### Step 2: Implement Connection Management with GORM
```go
// internal/db/db.go
package db

import (
    "context"
    "database/sql"
    "fmt"
    "time"
    
    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
)

const (
    maxOpenConns    = 25
    maxIdleConns    = 5
    connMaxLifetime = 5 * time.Minute
)

type DB struct {
    *gorm.DB
}

// New creates a new database connection with GORM
func New(dbPath string) (*DB, error) {
    dsn := fmt.Sprintf("%s?_foreign_keys=on&_journal_mode=WAL", dbPath)
    
    gormDB, err := gorm.Open(sqlite.Open(dsn), &gorm.Config{
        SkipDefaultTransaction: true,
        PrepareStmt:            true,
    })
    if err != nil {
        return nil, fmt.Errorf("failed to open database: %w", err)
    }
    
    // Get underlying sql.DB for connection pool configuration
    sqlDB, err := gormDB.DB()
    if err != nil {
        return nil, fmt.Errorf("failed to get underlying sql.DB: %w", err)
    }
    
    // Configure connection pool
    sqlDB.SetMaxOpenConns(maxOpenConns)
    sqlDB.SetMaxIdleConns(maxIdleConns)
    sqlDB.SetConnMaxLifetime(connMaxLifetime)
    
    // Verify connection
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    if err := sqlDB.PingContext(ctx); err != nil {
        return nil, fmt.Errorf("failed to ping database: %w", err)
    }
    
    return &DB{DB: gormDB}, nil
}

// Health checks database connectivity
func (db *DB) Health(ctx context.Context) error {
    sqlDB, err := db.DB.DB()
    if err != nil {
        return fmt.Errorf("failed to get underlying sql.DB: %w", err)
    }
    return sqlDB.PingContext(ctx)
}
```

### Step 3: Define Custom Error Types and GORM Error Mapping
```go
// internal/db/errors.go
package db

import (
    "errors"
    
    "gorm.io/gorm"
)

var (
    ErrNotFound     = errors.New("record not found")
    ErrDuplicate    = errors.New("duplicate record")
    ErrForeignKey   = errors.New("foreign key constraint violation")
    ErrInvalidInput = errors.New("invalid input")
)

// IsNotFound checks if error is a not found error
func IsNotFound(err error) bool {
    return errors.Is(err, ErrNotFound) || errors.Is(err, gorm.ErrRecordNotFound)
}

// IsDuplicate checks if error is a duplicate error
func IsDuplicate(err error) bool {
    return errors.Is(err, ErrDuplicate)
}

// MapGormError maps GORM errors to custom domain errors
func MapGormError(err error) error {
    if err == nil {
        return nil
    }
    if errors.Is(err, gorm.ErrRecordNotFound) {
        return ErrNotFound
    }
    // Check for SQLite constraint errors
    errMsg := err.Error()
    if containsAny(errMsg, []string{"UNIQUE constraint", "unique constraint"}) {
        return ErrDuplicate
    }
    if containsAny(errMsg, []string{"FOREIGN KEY constraint", "foreign key constraint"}) {
        return ErrForeignKey
    }
    return err
}
```

### Step 4: Implement Channel Repository with GORM
```go
// internal/db/channel.go
package db

import (
    "context"
    "fmt"
    "time"
    
    "github.com/google/uuid"
    "github.com/stwalsh4118/hermes/internal/models"
)

type ChannelRepository struct {
    db *DB
}

func NewChannelRepository(db *DB) *ChannelRepository {
    return &ChannelRepository{db: db}
}

func (r *ChannelRepository) Create(ctx context.Context, channel *models.Channel) error {
    result := r.db.WithContext(ctx).Create(channel)
    if result.Error != nil {
        return fmt.Errorf("failed to create channel: %w", MapGormError(result.Error))
    }
    return nil
}

func (r *ChannelRepository) GetByID(ctx context.Context, id uuid.UUID) (*models.Channel, error) {
    var channel models.Channel
    result := r.db.WithContext(ctx).Where("id = ?", id.String()).First(&channel)
    if result.Error != nil {
        return nil, MapGormError(result.Error)
    }
    return &channel, nil
}

func (r *ChannelRepository) List(ctx context.Context) ([]*models.Channel, error) {
    var channels []*models.Channel
    result := r.db.WithContext(ctx).Order("created_at DESC").Find(&channels)
    if result.Error != nil {
        return nil, fmt.Errorf("failed to list channels: %w", MapGormError(result.Error))
    }
    return channels, nil
}

func (r *ChannelRepository) Update(ctx context.Context, channel *models.Channel) error {
    channel.UpdatedAt = time.Now().UTC()
    result := r.db.WithContext(ctx).Where("id = ?", channel.ID.String()).Updates(channel)
    if result.Error != nil {
        return fmt.Errorf("failed to update channel: %w", MapGormError(result.Error))
    }
    if result.RowsAffected == 0 {
        return ErrNotFound
    }
    return nil
}

func (r *ChannelRepository) Delete(ctx context.Context, id uuid.UUID) error {
    result := r.db.WithContext(ctx).Where("id = ?", id.String()).Delete(&models.Channel{})
    if result.Error != nil {
        return fmt.Errorf("failed to delete channel: %w", MapGormError(result.Error))
    }
    if result.RowsAffected == 0 {
        return ErrNotFound
    }
    return nil
}
```

### Step 5: Implement Media Repository with GORM
- Similar CRUD operations as Channel using GORM
- Add GetByPath for duplicate checking
- Add ListByShow for filtering with GORM Where clause
- Include pagination support using GORM Limit and Offset

### Step 6: Implement PlaylistItem Repository with GORM
- CRUD operations using GORM
- Special method for reordering (update multiple positions in transaction)
- Method to get items with joined media data using GORM Preload
- Position uniqueness enforced by database schema

### Step 7: Implement Settings Repository with GORM
- Get() always returns single row (create with defaults if not exists) using GORM First
- Update() updates the single row using GORM Updates
- No Create or Delete methods (singleton table pattern)

### Step 8: Add Transaction Support with GORM
```go
// internal/db/transaction.go
package db

import (
    "context"
    "fmt"
    
    "gorm.io/gorm"
)

// WithTransaction executes a function within a database transaction
// GORM handles automatic commit on success and rollback on error or panic
func (db *DB) WithTransaction(ctx context.Context, fn func(*gorm.DB) error) error {
    return db.DB.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        if err := fn(tx); err != nil {
            return fmt.Errorf("transaction error: %w", err)
        }
        return nil
    })
}
```

### Step 9: Create Repository Factory
```go
// internal/db/repositories.go
package db

// Repositories provides access to all database repositories
type Repositories struct {
    Channels      *ChannelRepository
    Media         *MediaRepository
    PlaylistItems *PlaylistItemRepository
    Settings      *SettingsRepository
}

// NewRepositories creates a new repository collection
func NewRepositories(db *DB) *Repositories {
    return &Repositories{
        Channels:      NewChannelRepository(db),
        Media:         NewMediaRepository(db),
        PlaylistItems: NewPlaylistItemRepository(db),
        Settings:      NewSettingsRepository(db),
    }
}
```

## Test Plan

This task requires integration testing with an actual SQLite database using GORM.

### Success Criteria
1. GORM database connection established successfully
2. All CRUD operations work for each repository with GORM
3. Foreign key constraints enforced by database schema
4. GORM transactions commit and rollback correctly
5. Error handling returns appropriate error types via MapGormError
6. UUID conversion handled by GORM automatically
7. Timestamps set automatically by model constructors

### Test Scenarios

**Test 1: Channel CRUD with GORM**
```go
func TestChannelCRUD(t *testing.T) {
    db := setupTestDB(t)
    defer db.Close()
    
    repo := NewChannelRepository(db)
    ctx := context.Background()
    
    // Create
    channel := models.NewChannel("Test Channel", time.Now(), true)
    err := repo.Create(ctx, channel)
    assert.NoError(t, err)
    
    // Read
    fetched, err := repo.GetByID(ctx, channel.ID)
    assert.NoError(t, err)
    assert.Equal(t, channel.Name, fetched.Name)
    
    // Update
    fetched.Name = "Updated Channel"
    err = repo.Update(ctx, fetched)
    assert.NoError(t, err)
    
    // Delete
    err = repo.Delete(ctx, channel.ID)
    assert.NoError(t, err)
    
    // Verify deleted
    _, err = repo.GetByID(ctx, channel.ID)
    assert.Error(t, err)
    assert.True(t, IsNotFound(err))
}
```

**Test 2: Foreign Key Cascade**
```go
func TestCascadeDelete(t *testing.T) {
    // Create channel with GORM
    // Create playlist items for channel
    // Delete channel
    // Verify playlist items also deleted (cascade by DB schema)
}
```

**Test 3: Transaction Rollback with GORM**
```go
func TestTransactionRollback(t *testing.T) {
    // Use WithTransaction helper
    // Create channel in transaction
    // Force error to trigger rollback
    // Verify rollback - channel not created
}
```

## Verification

### Acceptance Criteria
- [ ] Database connection management implemented
- [ ] Connection pooling configured
- [ ] Custom error types defined
- [ ] Channel repository with full CRUD
- [ ] Media repository with full CRUD
- [ ] PlaylistItem repository with full CRUD
- [ ] Settings repository implemented
- [ ] Transaction support added
- [ ] Repository factory created
- [ ] All operations use context for cancellation
- [ ] Parameterized queries prevent SQL injection
- [ ] Foreign key constraints enforced
- [ ] UUID conversion handled correctly
- [ ] Error handling returns appropriate types
- [ ] Database health check implemented

### Definition of Done
- All acceptance criteria met
- All repositories tested with real database
- CRUD operations work correctly
- Foreign keys cascade properly
- Transactions commit and rollback as expected
- Error handling comprehensive

## Files Modified

### New Files Created
- `internal/db/db.go` - Connection management
- `internal/db/errors.go` - Custom error types
- `internal/db/channel.go` - Channel repository
- `internal/db/media.go` - Media repository
- `internal/db/playlist.go` - PlaylistItem repository
- `internal/db/settings.go` - Settings repository
- `internal/db/transaction.go` - Transaction support
- `internal/db/repositories.go` - Repository factory

### Modified Files
- None (pure additions)

## Notes

- SQLite doesn't support concurrent writes well - WAL mode is enabled for better concurrency
- UUIDs stored as TEXT in SQLite, GORM handles conversion to/from uuid.UUID
- Nullable fields use pointer types (*string, *int) in models
- GORM automatically uses parameterized queries (prevents SQL injection)
- GORM models use struct tags for column mapping (defined in task 1-6)
- Context passed via WithContext for cancellation support
- Repository pattern provides abstraction from GORM details
- Schema managed by golang-migrate, not GORM auto-migrate
- Settings table always has exactly one row (singleton pattern)
- GORM Transaction method handles commit/rollback automatically
- MapGormError translates GORM errors to domain errors

