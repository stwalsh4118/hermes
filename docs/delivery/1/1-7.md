# [1-7] Implement Database Layer

[Back to task list](./tasks.md)

## Description

Implement the database access layer using the repository pattern. This includes connection management, CRUD operations for all models, transaction support, and proper error handling. The implementation will use database/sql with SQLite driver and provide a clean abstraction for data access.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-26 12:00:00 | Created | N/A | Proposed | Task file created | AI_Agent |

## Requirements

### Functional Requirements
- Database connection management with pooling
- Repository interface for each model
- CRUD operations: Create, Read (by ID, List), Update, Delete
- Transaction support for multi-operation consistency
- Proper error handling and wrapping
- Connection health check
- Automatic UUID generation on create
- Timestamp management (created_at, updated_at)

### Repository Operations

**Channel Repository:**
- Create(channel) - Insert new channel
- GetByID(id) - Get channel by UUID
- List() - Get all channels
- Update(channel) - Update existing channel
- Delete(id) - Delete channel (cascade to playlist items)
- GetWithPlaylist(id) - Get channel with playlist items

**Media Repository:**
- Create(media) - Insert new media
- GetByID(id) - Get media by UUID
- GetByPath(path) - Get media by file path
- List() - Get all media with pagination
- ListByShow(showName) - Get media filtered by show
- Update(media) - Update media metadata
- Delete(id) - Delete media

**PlaylistItem Repository:**
- Create(item) - Insert playlist item
- GetByChannelID(channelID) - Get all items for channel, ordered by position
- GetByID(id) - Get single playlist item
- Delete(id) - Delete playlist item
- DeleteByChannelID(channelID) - Delete all items for channel
- Reorder(channelID, items) - Update positions for reordering
- GetWithMedia(channelID) - Get playlist items with joined media

**Settings Repository:**
- Get() - Get settings (always returns single row)
- Update(settings) - Update settings

### Technical Requirements
- Use database/sql package
- SQLite driver: mattn/go-sqlite3
- Prepare and use parameterized queries (prevent SQL injection)
- Return custom error types for not found, constraint violations
- Use context for cancellation support
- Enable foreign key constraints on connection
- Enable WAL mode for better concurrency
- Connection pooling configuration

## Implementation Plan

### Step 1: Create Database Package Structure
```
internal/db/
├── db.go              # Connection management
├── errors.go          # Custom error types
├── migrations.go      # Migration runner (from task 1-5)
├── channel.go         # Channel repository
├── media.go           # Media repository
├── playlist.go        # Playlist repository
└── settings.go        # Settings repository
```

### Step 2: Implement Connection Management
```go
// internal/db/db.go
package db

import (
    "context"
    "database/sql"
    "fmt"
    "time"
    
    _ "github.com/mattn/go-sqlite3"
)

const (
    maxOpenConns    = 25
    maxIdleConns    = 5
    connMaxLifetime = 5 * time.Minute
)

type DB struct {
    *sql.DB
}

// New creates a new database connection
func New(dbPath string) (*DB, error) {
    sqlDB, err := sql.Open("sqlite3", fmt.Sprintf("%s?_foreign_keys=on&_journal_mode=WAL", dbPath))
    if err != nil {
        return nil, fmt.Errorf("failed to open database: %w", err)
    }
    
    // Configure connection pool
    sqlDB.SetMaxOpenConns(maxOpenConns)
    sqlDB.SetMaxIdleConns(maxIdleConns)
    sqlDB.SetConnMaxLifetime(connMaxLifetime)
    
    // Verify connection
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    if err := sqlDB.PingContext(ctx); err != nil {
        return nil, fmt.Errorf("failed to ping database: %w", err)
    }
    
    return &DB{DB: sqlDB}, nil
}

// Health checks database connectivity
func (db *DB) Health(ctx context.Context) error {
    return db.PingContext(ctx)
}
```

### Step 3: Define Custom Error Types
```go
// internal/db/errors.go
package db

import (
    "errors"
    "fmt"
)

var (
    ErrNotFound      = errors.New("record not found")
    ErrDuplicate     = errors.New("duplicate record")
    ErrForeignKey    = errors.New("foreign key constraint violation")
    ErrInvalidInput  = errors.New("invalid input")
)

// IsNotFound checks if error is a not found error
func IsNotFound(err error) bool {
    return errors.Is(err, ErrNotFound)
}

// IsDuplicate checks if error is a duplicate error
func IsDuplicate(err error) bool {
    return errors.Is(err, ErrDuplicate)
}
```

### Step 4: Implement Channel Repository
```go
// internal/db/channel.go
package db

import (
    "context"
    "database/sql"
    "fmt"
    
    "yourmodule/internal/models"
    "github.com/google/uuid"
)

type ChannelRepository struct {
    db *DB
}

func NewChannelRepository(db *DB) *ChannelRepository {
    return &ChannelRepository{db: db}
}

func (r *ChannelRepository) Create(ctx context.Context, channel *models.Channel) error {
    query := `
        INSERT INTO channels (id, name, icon, start_time, loop, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?)
    `
    
    _, err := r.db.ExecContext(ctx, query,
        channel.ID.String(),
        channel.Name,
        channel.Icon,
        channel.StartTime,
        channel.Loop,
        channel.CreatedAt,
        channel.UpdatedAt,
    )
    
    if err != nil {
        return fmt.Errorf("failed to create channel: %w", err)
    }
    
    return nil
}

func (r *ChannelRepository) GetByID(ctx context.Context, id uuid.UUID) (*models.Channel, error) {
    query := `
        SELECT id, name, icon, start_time, loop, created_at, updated_at
        FROM channels
        WHERE id = ?
    `
    
    var channel models.Channel
    var idStr string
    
    err := r.db.QueryRowContext(ctx, query, id.String()).Scan(
        &idStr,
        &channel.Name,
        &channel.Icon,
        &channel.StartTime,
        &channel.Loop,
        &channel.CreatedAt,
        &channel.UpdatedAt,
    )
    
    if err == sql.ErrNoRows {
        return nil, ErrNotFound
    }
    if err != nil {
        return nil, fmt.Errorf("failed to get channel: %w", err)
    }
    
    channel.ID = uuid.MustParse(idStr)
    return &channel, nil
}

func (r *ChannelRepository) List(ctx context.Context) ([]*models.Channel, error) {
    query := `
        SELECT id, name, icon, start_time, loop, created_at, updated_at
        FROM channels
        ORDER BY created_at DESC
    `
    
    rows, err := r.db.QueryContext(ctx, query)
    if err != nil {
        return nil, fmt.Errorf("failed to list channels: %w", err)
    }
    defer rows.Close()
    
    var channels []*models.Channel
    for rows.Next() {
        var channel models.Channel
        var idStr string
        
        err := rows.Scan(
            &idStr,
            &channel.Name,
            &channel.Icon,
            &channel.StartTime,
            &channel.Loop,
            &channel.CreatedAt,
            &channel.UpdatedAt,
        )
        if err != nil {
            return nil, fmt.Errorf("failed to scan channel: %w", err)
        }
        
        channel.ID = uuid.MustParse(idStr)
        channels = append(channels, &channel)
    }
    
    return channels, nil
}

func (r *ChannelRepository) Update(ctx context.Context, channel *models.Channel) error {
    query := `
        UPDATE channels
        SET name = ?, icon = ?, start_time = ?, loop = ?, updated_at = ?
        WHERE id = ?
    `
    
    channel.UpdatedAt = time.Now().UTC()
    
    result, err := r.db.ExecContext(ctx, query,
        channel.Name,
        channel.Icon,
        channel.StartTime,
        channel.Loop,
        channel.UpdatedAt,
        channel.ID.String(),
    )
    
    if err != nil {
        return fmt.Errorf("failed to update channel: %w", err)
    }
    
    rows, err := result.RowsAffected()
    if err != nil {
        return fmt.Errorf("failed to get rows affected: %w", err)
    }
    
    if rows == 0 {
        return ErrNotFound
    }
    
    return nil
}

func (r *ChannelRepository) Delete(ctx context.Context, id uuid.UUID) error {
    query := `DELETE FROM channels WHERE id = ?`
    
    result, err := r.db.ExecContext(ctx, query, id.String())
    if err != nil {
        return fmt.Errorf("failed to delete channel: %w", err)
    }
    
    rows, err := result.RowsAffected()
    if err != nil {
        return fmt.Errorf("failed to get rows affected: %w", err)
    }
    
    if rows == 0 {
        return ErrNotFound
    }
    
    return nil
}
```

### Step 5: Implement Media Repository
- Similar CRUD operations as Channel
- Add GetByPath for duplicate checking
- Add ListByShow for filtering
- Include pagination support

### Step 6: Implement PlaylistItem Repository
- CRUD operations
- Special method for reordering (update multiple positions)
- Method to get items with joined media data
- Ensure position uniqueness per channel

### Step 7: Implement Settings Repository
- Get() always returns single row (create if not exists)
- Update() updates the single row
- No Create or Delete (single row table)

### Step 8: Add Transaction Support
```go
// internal/db/transaction.go
package db

import (
    "context"
    "database/sql"
    "fmt"
)

// WithTransaction executes a function within a transaction
func (db *DB) WithTransaction(ctx context.Context, fn func(*sql.Tx) error) error {
    tx, err := db.BeginTx(ctx, nil)
    if err != nil {
        return fmt.Errorf("failed to begin transaction: %w", err)
    }
    
    defer func() {
        if p := recover(); p != nil {
            tx.Rollback()
            panic(p)
        }
    }()
    
    if err := fn(tx); err != nil {
        if rbErr := tx.Rollback(); rbErr != nil {
            return fmt.Errorf("transaction error: %v, rollback error: %w", err, rbErr)
        }
        return err
    }
    
    if err := tx.Commit(); err != nil {
        return fmt.Errorf("failed to commit transaction: %w", err)
    }
    
    return nil
}
```

### Step 9: Create Repository Factory
```go
// internal/db/repositories.go
package db

type Repositories struct {
    Channels      *ChannelRepository
    Media         *MediaRepository
    PlaylistItems *PlaylistItemRepository
    Settings      *SettingsRepository
}

func NewRepositories(db *DB) *Repositories {
    return &Repositories{
        Channels:      NewChannelRepository(db),
        Media:         NewMediaRepository(db),
        PlaylistItems: NewPlaylistItemRepository(db),
        Settings:      NewSettingsRepository(db),
    }
}
```

## Test Plan

This task requires integration testing with an actual SQLite database.

### Success Criteria
1. Database connection established successfully
2. All CRUD operations work for each repository
3. Foreign key constraints enforced
4. Transactions commit and rollback correctly
5. Error handling returns appropriate error types
6. UUID conversion works correctly
7. Timestamps set automatically

### Test Scenarios

**Test 1: Channel CRUD**
```go
func TestChannelCRUD(t *testing.T) {
    db := setupTestDB(t)
    defer db.Close()
    
    repo := NewChannelRepository(db)
    ctx := context.Background()
    
    // Create
    channel := models.NewChannel("Test Channel", time.Now(), true)
    err := repo.Create(ctx, channel)
    assert.NoError(t, err)
    
    // Read
    fetched, err := repo.GetByID(ctx, channel.ID)
    assert.NoError(t, err)
    assert.Equal(t, channel.Name, fetched.Name)
    
    // Update
    fetched.Name = "Updated Channel"
    err = repo.Update(ctx, fetched)
    assert.NoError(t, err)
    
    // Delete
    err = repo.Delete(ctx, channel.ID)
    assert.NoError(t, err)
    
    // Verify deleted
    _, err = repo.GetByID(ctx, channel.ID)
    assert.Error(t, err)
    assert.True(t, IsNotFound(err))
}
```

**Test 2: Foreign Key Cascade**
```go
func TestCascadeDelete(t *testing.T) {
    // Create channel with playlist items
    // Delete channel
    // Verify playlist items also deleted
}
```

**Test 3: Transaction Rollback**
```go
func TestTransactionRollback(t *testing.T) {
    // Start transaction
    // Create channel
    // Force error
    // Verify rollback - channel not created
}
```

## Verification

### Acceptance Criteria
- [ ] Database connection management implemented
- [ ] Connection pooling configured
- [ ] Custom error types defined
- [ ] Channel repository with full CRUD
- [ ] Media repository with full CRUD
- [ ] PlaylistItem repository with full CRUD
- [ ] Settings repository implemented
- [ ] Transaction support added
- [ ] Repository factory created
- [ ] All operations use context for cancellation
- [ ] Parameterized queries prevent SQL injection
- [ ] Foreign key constraints enforced
- [ ] UUID conversion handled correctly
- [ ] Error handling returns appropriate types
- [ ] Database health check implemented

### Definition of Done
- All acceptance criteria met
- All repositories tested with real database
- CRUD operations work correctly
- Foreign keys cascade properly
- Transactions commit and rollback as expected
- Error handling comprehensive

## Files Modified

### New Files Created
- `internal/db/db.go` - Connection management
- `internal/db/errors.go` - Custom error types
- `internal/db/channel.go` - Channel repository
- `internal/db/media.go` - Media repository
- `internal/db/playlist.go` - PlaylistItem repository
- `internal/db/settings.go` - Settings repository
- `internal/db/transaction.go` - Transaction support
- `internal/db/repositories.go` - Repository factory

### Modified Files
- None (pure additions)

## Notes

- SQLite doesn't support concurrent writes well - consider using WAL mode
- UUIDs stored as TEXT and converted to/from uuid.UUID in Go
- Nullable fields require careful handling with sql.Null* types or pointers
- Consider using sqlx library for struct scanning in future refactoring
- Parameterized queries (?) prevent SQL injection
- Context should be checked for cancellation in long operations
- Repository pattern provides abstraction from SQL details
- Consider adding connection retry logic for production
- Settings table always has exactly one row - handle accordingly

