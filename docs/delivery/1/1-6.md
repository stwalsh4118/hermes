# [1-6] Define Data Models

[Back to task list](./tasks.md)

## Description

Create Go struct definitions for all domain entities (Channel, Media, PlaylistItem, Settings, StreamSession) that match the database schema and PRD specifications. These models serve as the application's data layer, providing type safety and encapsulation for business logic.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-26 12:00:00 | Created | N/A | Proposed | Task file created | AI_Agent |

## Requirements

### Functional Requirements
- Define struct for each entity
- Include JSON tags for API serialization
- Include database tags for SQL mapping
- Use appropriate Go types matching SQLite schema
- Include validation tags where appropriate
- Support UUID types for IDs
- Include time.Time for datetime fields

### Models to Create
1. **Channel** - TV channel entity
2. **Media** - Media file metadata
3. **PlaylistItem** - Channel playlist entry
4. **Settings** - System configuration
5. **StreamSession** - Runtime streaming state (in-memory only)

### Technical Requirements
- Use google/uuid for ID types
- Use time.Time for datetime fields
- Pointer types for nullable fields
- Consistent naming conventions
- All models in internal/models package
- Include helper methods where appropriate

## Implementation Plan

### Step 1: Create Models Package
- Create `internal/models/` directory
- Create separate file for each model
- Create `types.go` for shared types/constants

### Step 2: Define Channel Model
```go
// internal/models/channel.go
package models

import (
    "time"
    
    "github.com/google/uuid"
)

type Channel struct {
    ID        uuid.UUID `json:"id" db:"id"`
    Name      string    `json:"name" db:"name" validate:"required,min=1,max=255"`
    Icon      *string   `json:"icon,omitempty" db:"icon"`
    StartTime time.Time `json:"start_time" db:"start_time" validate:"required"`
    Loop      bool      `json:"loop" db:"loop"`
    CreatedAt time.Time `json:"created_at" db:"created_at"`
    UpdatedAt time.Time `json:"updated_at" db:"updated_at"`
}

// NewChannel creates a new Channel with generated UUID
func NewChannel(name string, startTime time.Time, loop bool) *Channel {
    now := time.Now().UTC()
    return &Channel{
        ID:        uuid.New(),
        Name:      name,
        StartTime: startTime,
        Loop:      loop,
        CreatedAt: now,
        UpdatedAt: now,
    }
}
```

### Step 3: Define Media Model
```go
// internal/models/media.go
package models

import (
    "time"
    
    "github.com/google/uuid"
)

type Media struct {
    ID         uuid.UUID `json:"id" db:"id"`
    FilePath   string    `json:"file_path" db:"file_path" validate:"required"`
    Title      string    `json:"title" db:"title" validate:"required"`
    ShowName   *string   `json:"show_name,omitempty" db:"show_name"`
    Season     *int      `json:"season,omitempty" db:"season"`
    Episode    *int      `json:"episode,omitempty" db:"episode"`
    Duration   int64     `json:"duration" db:"duration" validate:"required,gt=0"` // seconds
    VideoCodec *string   `json:"video_codec,omitempty" db:"video_codec"`
    AudioCodec *string   `json:"audio_codec,omitempty" db:"audio_codec"`
    Resolution *string   `json:"resolution,omitempty" db:"resolution"`
    FileSize   *int64    `json:"file_size,omitempty" db:"file_size"`
    CreatedAt  time.Time `json:"created_at" db:"created_at"`
}

// NewMedia creates a new Media with generated UUID
func NewMedia(filePath, title string, duration int64) *Media {
    return &Media{
        ID:        uuid.New(),
        FilePath:  filePath,
        Title:     title,
        Duration:  duration,
        CreatedAt: time.Now().UTC(),
    }
}

// DurationString returns duration in HH:MM:SS format
func (m *Media) DurationString() string {
    hours := m.Duration / 3600
    minutes := (m.Duration % 3600) / 60
    seconds := m.Duration % 60
    return fmt.Sprintf("%02d:%02d:%02d", hours, minutes, seconds)
}
```

### Step 4: Define PlaylistItem Model
```go
// internal/models/playlist_item.go
package models

import (
    "time"
    
    "github.com/google/uuid"
)

type PlaylistItem struct {
    ID        uuid.UUID `json:"id" db:"id"`
    ChannelID uuid.UUID `json:"channel_id" db:"channel_id" validate:"required"`
    MediaID   uuid.UUID `json:"media_id" db:"media_id" validate:"required"`
    Position  int       `json:"position" db:"position" validate:"gte=0"`
    CreatedAt time.Time `json:"created_at" db:"created_at"`
    
    // Populated by joins, not stored
    Media *Media `json:"media,omitempty" db:"-"`
}

// NewPlaylistItem creates a new PlaylistItem with generated UUID
func NewPlaylistItem(channelID, mediaID uuid.UUID, position int) *PlaylistItem {
    return &PlaylistItem{
        ID:        uuid.New(),
        ChannelID: channelID,
        MediaID:   mediaID,
        Position:  position,
        CreatedAt: time.Now().UTC(),
    }
}
```

### Step 5: Define Settings Model
```go
// internal/models/settings.go
package models

import (
    "time"
)

const (
    QualityHigh   = "high"
    QualityMedium = "medium"
    QualityLow    = "low"
    
    HardwareAccelNone        = "none"
    HardwareAccelNVENC       = "nvenc"
    HardwareAccelQSV         = "qsv"
    HardwareAccelVAAPI       = "vaapi"
    HardwareAccelVideoToolbox = "videotoolbox"
)

type Settings struct {
    ID               int       `json:"id" db:"id"`
    MediaLibraryPath string    `json:"media_library_path" db:"media_library_path" validate:"required"`
    TranscodeQuality string    `json:"transcode_quality" db:"transcode_quality" validate:"oneof=high medium low"`
    HardwareAccel    string    `json:"hardware_accel" db:"hardware_accel" validate:"oneof=none nvenc qsv vaapi videotoolbox"`
    ServerPort       int       `json:"server_port" db:"server_port" validate:"gte=1,lte=65535"`
    UpdatedAt        time.Time `json:"updated_at" db:"updated_at"`
}

// DefaultSettings returns settings with default values
func DefaultSettings() *Settings {
    return &Settings{
        ID:               1,
        MediaLibraryPath: "./media",
        TranscodeQuality: QualityMedium,
        HardwareAccel:    HardwareAccelNone,
        ServerPort:       8080,
        UpdatedAt:        time.Now().UTC(),
    }
}
```

### Step 6: Define StreamSession Model (In-Memory)
```go
// internal/models/stream_session.go
package models

import (
    "time"
    
    "github.com/google/uuid"
)

// StreamSession represents an active streaming session
// This is NOT persisted to database, only kept in memory
type StreamSession struct {
    ID          uuid.UUID `json:"id"`
    ChannelID   uuid.UUID `json:"channel_id"`
    StartedAt   time.Time `json:"started_at"`
    ClientCount int       `json:"client_count"`
    FFmpegPID   int       `json:"ffmpeg_pid"`
}

// NewStreamSession creates a new stream session
func NewStreamSession(channelID uuid.UUID) *StreamSession {
    return &StreamSession{
        ID:          uuid.New(),
        ChannelID:   channelID,
        StartedAt:   time.Now().UTC(),
        ClientCount: 0,
        FFmpegPID:   0,
    }
}

// IncrementClients increases the client count
func (s *StreamSession) IncrementClients() {
    s.ClientCount++
}

// DecrementClients decreases the client count
func (s *StreamSession) DecrementClients() {
    if s.ClientCount > 0 {
        s.ClientCount--
    }
}

// IsActive returns true if session has active clients
func (s *StreamSession) IsActive() bool {
    return s.ClientCount > 0
}
```

### Step 7: Create Common Types File
```go
// internal/models/types.go
package models

// Useful type aliases and shared types can go here
```

### Step 8: Add Helper Functions
- UUID string conversion helpers
- Validation helpers
- Time formatting helpers

## Test Plan

This task involves struct definitions; testing focuses on compilation and basic functionality.

### Success Criteria
1. All models compile without errors
2. JSON marshaling/unmarshaling works correctly
3. Constructor functions create valid instances
4. Helper methods work as expected
5. Validation tags are appropriate
6. UUIDs generate correctly

### Test Cases

**Test 1: Model Creation and JSON Serialization**
```go
func TestChannelJSON(t *testing.T) {
    channel := NewChannel("Test Channel", time.Now(), true)
    
    // Test JSON marshaling
    data, err := json.Marshal(channel)
    assert.NoError(t, err)
    
    // Test JSON unmarshaling
    var decoded Channel
    err = json.Unmarshal(data, &decoded)
    assert.NoError(t, err)
    assert.Equal(t, channel.Name, decoded.Name)
}
```

**Test 2: UUID Generation**
```go
func TestUUIDGeneration(t *testing.T) {
    media1 := NewMedia("/path/to/video.mp4", "Video Title", 600)
    media2 := NewMedia("/path/to/video2.mp4", "Video Title 2", 700)
    
    // UUIDs should be different
    assert.NotEqual(t, media1.ID, media2.ID)
    
    // UUIDs should be valid
    assert.NotEqual(t, uuid.Nil, media1.ID)
}
```

**Test 3: Helper Methods**
```go
func TestMediaDurationString(t *testing.T) {
    media := NewMedia("/test.mp4", "Test", 3665) // 1h 1m 5s
    assert.Equal(t, "01:01:05", media.DurationString())
}

func TestStreamSessionClientCount(t *testing.T) {
    session := NewStreamSession(uuid.New())
    
    assert.Equal(t, 0, session.ClientCount)
    assert.False(t, session.IsActive())
    
    session.IncrementClients()
    assert.Equal(t, 1, session.ClientCount)
    assert.True(t, session.IsActive())
    
    session.DecrementClients()
    assert.Equal(t, 0, session.ClientCount)
    assert.False(t, session.IsActive())
}
```

**Test 4: Nullable Fields**
```go
func TestNullableFields(t *testing.T) {
    media := NewMedia("/test.mp4", "Test", 100)
    
    // Optional fields should be nil
    assert.Nil(t, media.ShowName)
    assert.Nil(t, media.Season)
    
    // Can set optional fields
    showName := "Test Show"
    season := 1
    media.ShowName = &showName
    media.Season = &season
    
    assert.Equal(t, "Test Show", *media.ShowName)
    assert.Equal(t, 1, *media.Season)
}
```

## Verification

### Acceptance Criteria
- [ ] Models package created in internal/models/
- [ ] Channel model defined with all fields and tags
- [ ] Media model defined with all fields and tags
- [ ] PlaylistItem model defined with all fields and tags
- [ ] Settings model defined with all fields and tags
- [ ] StreamSession model defined (in-memory only)
- [ ] All models use uuid.UUID for IDs
- [ ] All models use time.Time for datetime fields
- [ ] Nullable fields use pointer types
- [ ] JSON tags present on all fields
- [ ] Database tags present on persisted fields
- [ ] Constructor functions provided
- [ ] Helper methods implemented where useful
- [ ] Constants defined for enum-like values
- [ ] All code compiles without errors

### Definition of Done
- All acceptance criteria met
- Models match database schema exactly
- JSON serialization works correctly
- Constructor functions create valid instances
- Helper methods tested and working

## Files Modified

### New Files Created
- `internal/models/channel.go` - Channel model
- `internal/models/media.go` - Media model
- `internal/models/playlist_item.go` - PlaylistItem model
- `internal/models/settings.go` - Settings model
- `internal/models/stream_session.go` - StreamSession model
- `internal/models/types.go` - Shared types and constants

### Modified Files
- None (pure additions)

## Notes

- Pointer types (*string, *int) used for nullable database columns
- JSON tags include `omitempty` for optional fields
- Validation tags prepare for future validation integration
- db tags used by sqlx for struct scanning
- db:"-" excludes fields from database mapping (e.g., joined data)
- UUID.String() method converts UUID to string representation
- Time fields stored/transmitted in UTC
- StreamSession is runtime-only, never persisted
- Consider adding validation methods (Validate()) in future
- Settings constants help prevent typos and enable autocomplete

