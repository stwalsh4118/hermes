# [1-8] Set Up Gin Server with Health Check

[Back to task list](./tasks.md)

## Description

Initialize the Gin web framework as the HTTP server foundation for the Virtual TV Channel Service. This includes setting up the router, adding essential middleware (logging, recovery, CORS), implementing a health check endpoint, and configuring graceful shutdown. This task integrates all previous work into a running web server.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-26 12:00:00 | Created | N/A | Proposed | Task file created | AI_Agent |
| 2025-10-27 11:55:00 | Status Update | Proposed | InProgress | Started implementation | AI_Agent |
| 2025-10-27 12:00:00 | Status Update | InProgress | Review | Implementation complete, ready for review | AI_Agent |
| 2025-10-27 12:01:00 | Status Update | Review | Done | Task approved and completed | User |

## Requirements

### Functional Requirements
- Initialize Gin router in appropriate mode (release/debug)
- Add request logging middleware (using zerolog from task 1-3)
- Add recovery middleware for panic handling
- Add CORS middleware for cross-origin requests
- Implement health check endpoint at /api/health
- Configure server timeouts from config
- Implement graceful shutdown on SIGINT/SIGTERM
- Integrate database connection and run migrations on startup

### API Endpoints to Implement
- `GET /api/health` - Health check endpoint
  - Returns 200 OK with server status
  - Includes database connectivity check
  - Returns JSON with status information

### Technical Requirements
- Use Gin framework
- Server runs on configured port (from task 1-4)
- Graceful shutdown allows in-flight requests to complete
- Structured logging for all requests (from task 1-3)
- CORS configured for frontend access
- Panic recovery prevents server crashes
- All components initialized in correct order

## Implementation Plan

### Step 1: Create Server Package
```go
// internal/server/server.go
package server

import (
    "context"
    "fmt"
    "net/http"
    "time"
    
    "github.com/gin-gonic/gin"
    "yourmodule/internal/config"
    "yourmodule/internal/db"
    "yourmodule/internal/logger"
)

const (
    shutdownTimeout = 10 * time.Second
)

type Server struct {
    config *config.Config
    db     *db.DB
    router *gin.Engine
    server *http.Server
}

func New(cfg *config.Config, database *db.DB) *Server {
    return &Server{
        config: cfg,
        db:     database,
    }
}
```

### Step 2: Initialize Gin Router with Middleware
```go
func (s *Server) setupRouter() {
    // Set Gin mode based on log level
    if s.config.Logging.Level == "debug" {
        gin.SetMode(gin.DebugMode)
    } else {
        gin.SetMode(gin.ReleaseMode)
    }
    
    s.router = gin.New()
    
    // Add middleware
    s.router.Use(middleware.RequestLogger())  // From task 1-3
    s.router.Use(gin.Recovery())
    s.router.Use(middleware.CORS())
    
    // Register routes
    s.registerRoutes()
}
```

### Step 3: Create CORS Middleware
```go
// internal/middleware/cors.go
package middleware

import (
    "github.com/gin-gonic/gin"
)

func CORS() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
        c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
        c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
        c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE, PATCH")
        
        if c.Request.Method == "OPTIONS" {
            c.AbortWithStatus(204)
            return
        }
        
        c.Next()
    }
}
```

### Step 4: Implement Health Check Handler
```go
// internal/api/health.go
package api

import (
    "context"
    "net/http"
    "time"
    
    "github.com/gin-gonic/gin"
    "yourmodule/internal/db"
)

type HealthHandler struct {
    db *db.DB
}

func NewHealthHandler(database *db.DB) *HealthHandler {
    return &HealthHandler{db: database}
}

type HealthResponse struct {
    Status   string                 `json:"status"`
    Database string                 `json:"database"`
    Time     string                 `json:"time"`
    Details  map[string]interface{} `json:"details,omitempty"`
}

func (h *HealthHandler) Check(c *gin.Context) {
    ctx, cancel := context.WithTimeout(c.Request.Context(), 2*time.Second)
    defer cancel()
    
    response := HealthResponse{
        Status:  "ok",
        Time:    time.Now().UTC().Format(time.RFC3339),
        Details: make(map[string]interface{}),
    }
    
    // Check database connectivity
    if err := h.db.Health(ctx); err != nil {
        response.Status = "degraded"
        response.Database = "unhealthy"
        response.Details["database_error"] = err.Error()
        c.JSON(http.StatusServiceUnavailable, response)
        return
    }
    
    response.Database = "healthy"
    c.JSON(http.StatusOK, response)
}
```

### Step 5: Register Routes
```go
// internal/server/routes.go
package server

import (
    "yourmodule/internal/api"
)

func (s *Server) registerRoutes() {
    // API group
    apiGroup := s.router.Group("/api")
    
    // Health check
    healthHandler := api.NewHealthHandler(s.db)
    apiGroup.GET("/health", healthHandler.Check)
    
    // Future endpoints will be added here in subsequent tasks
}
```

### Step 6: Implement Server Start Method
```go
func (s *Server) Start() error {
    s.setupRouter()
    
    addr := fmt.Sprintf("%s:%d", s.config.Server.Host, s.config.Server.Port)
    
    s.server = &http.Server{
        Addr:           addr,
        Handler:        s.router,
        ReadTimeout:    s.config.Server.ReadTimeout,
        WriteTimeout:   s.config.Server.WriteTimeout,
        MaxHeaderBytes: 1 << 20, // 1 MB
    }
    
    logger.Log.Info().
        Str("host", s.config.Server.Host).
        Int("port", s.config.Server.Port).
        Msg("Starting HTTP server")
    
    return s.server.ListenAndServe()
}
```

### Step 7: Implement Graceful Shutdown
```go
func (s *Server) Shutdown(ctx context.Context) error {
    logger.Log.Info().Msg("Shutting down server gracefully")
    
    if err := s.server.Shutdown(ctx); err != nil {
        return fmt.Errorf("server shutdown error: %w", err)
    }
    
    logger.Log.Info().Msg("Server stopped")
    return nil
}
```

### Step 8: Update main.go to Integrate Everything
```go
// cmd/server/main.go
package main

import (
    "context"
    "fmt"
    "os"
    "os/signal"
    "syscall"
    "time"
    
    "yourmodule/internal/config"
    "yourmodule/internal/db"
    "yourmodule/internal/logger"
    "yourmodule/internal/server"
)

const shutdownTimeout = 10 * time.Second

func main() {
    // Load configuration
    cfg, err := config.Load()
    if err != nil {
        fmt.Fprintf(os.Stderr, "Failed to load configuration: %v\n", err)
        os.Exit(1)
    }
    
    // Initialize logger
    logger.Init(cfg.Logging.Level, cfg.Logging.Pretty)
    logger.Log.Info().Msg("Starting Virtual TV Channel Service")
    
    // Connect to database
    database, err := db.New(cfg.Database.Path)
    if err != nil {
        logger.Log.Fatal().Err(err).Msg("Failed to connect to database")
    }
    defer database.Close()
    
    logger.Log.Info().Str("path", cfg.Database.Path).Msg("Connected to database")
    
    // Run migrations
    if err := db.RunMigrations(database.DB, "migrations"); err != nil {
        logger.Log.Fatal().Err(err).Msg("Failed to run migrations")
    }
    
    logger.Log.Info().Msg("Database migrations completed")
    
    // Create and start server
    srv := server.New(cfg, database)
    
    // Channel to listen for errors from the server
    serverErrors := make(chan error, 1)
    
    // Start server in goroutine
    go func() {
        serverErrors <- srv.Start()
    }()
    
    // Channel to listen for interrupt signals
    shutdown := make(chan os.Signal, 1)
    signal.Notify(shutdown, os.Interrupt, syscall.SIGTERM)
    
    // Block until we receive an error or interrupt signal
    select {
    case err := <-serverErrors:
        logger.Log.Fatal().Err(err).Msg("Server error")
        
    case sig := <-shutdown:
        logger.Log.Info().
            Str("signal", sig.String()).
            Msg("Shutdown signal received")
        
        // Give outstanding requests time to complete
        ctx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
        defer cancel()
        
        if err := srv.Shutdown(ctx); err != nil {
            logger.Log.Error().Err(err).Msg("Graceful shutdown failed")
            os.Exit(1)
        }
    }
    
    logger.Log.Info().Msg("Server stopped successfully")
}
```

### Step 9: Add Startup Banner (Optional)
- Log application name and version
- Log configuration summary (port, database, log level)
- Log available endpoints

## Test Plan

This task integrates all components; testing verifies the full stack works together.

### Success Criteria
1. Server starts without errors
2. Health check endpoint returns 200 OK
3. Health check includes database status
4. Request logging works (logs appear for each request)
5. CORS headers present in responses
6. Panic recovery prevents crashes
7. Graceful shutdown completes successfully
8. Configuration loaded from file/env
9. Database migrations run on startup
10. All middleware executes in correct order

### Manual Testing

**Test 1: Start Server**
```bash
go run ./cmd/server

# Should see logs:
# - Configuration loaded
# - Logger initialized
# - Database connected
# - Migrations completed
# - Server started on port 8080
```

**Test 2: Health Check**
```bash
curl -v http://localhost:8080/api/health

# Expected response:
HTTP/1.1 200 OK
Content-Type: application/json
{
  "status": "ok",
  "database": "healthy",
  "time": "2025-10-26T12:00:00Z"
}
```

**Test 3: CORS Headers**
```bash
curl -v -X OPTIONS http://localhost:8080/api/health

# Should see CORS headers:
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: POST, OPTIONS, GET, PUT, DELETE, PATCH
```

**Test 4: Request Logging**
```bash
# Make request
curl http://localhost:8080/api/health

# Check logs - should see:
# {"level":"info","method":"GET","path":"/api/health","status":200,...}
```

**Test 5: Graceful Shutdown**
```bash
# Start server
go run ./cmd/server

# In another terminal, make long request (if available)
# Press Ctrl+C

# Should see:
# - "Shutdown signal received"
# - In-flight requests complete
# - "Server stopped successfully"
```

**Test 6: Database Health Check Failure**
```bash
# Start server with invalid database path
DATABASE_PATH=/nonexistent/db go run ./cmd/server

# Health check should return 503 with error details
```

### Integration Test
```go
func TestServerIntegration(t *testing.T) {
    // Setup test database
    // Start server
    // Make health check request
    // Verify response
    // Shutdown server
}
```

## Verification

### Acceptance Criteria
- [ ] Gin router initialized and configured
- [ ] Request logging middleware integrated (from task 1-3)
- [ ] Recovery middleware added
- [ ] CORS middleware configured
- [ ] Health check endpoint implemented at /api/health
- [ ] Health check includes database connectivity test
- [ ] Health check returns proper JSON response
- [ ] Server starts on configured port
- [ ] Server configured with timeouts from config
- [ ] Graceful shutdown implemented
- [ ] Signal handling for SIGINT/SIGTERM
- [ ] Database connection established on startup
- [ ] Database migrations run on startup
- [ ] Configuration loaded before server start
- [ ] Logger initialized before server start
- [ ] All logs use zerolog
- [ ] Server can be stopped cleanly

### Definition of Done
- All acceptance criteria met
- Server starts and responds to health checks
- All middleware functioning correctly
- Graceful shutdown works as expected
- Integration of all previous tasks successful
- README updated with running instructions

## Files Modified

### New Files Created
- `internal/server/server.go` - Server struct and lifecycle management (setupRouter, Start, Shutdown)
- `internal/api/health.go` - Health check handler with SetupHealthRoutes function

### Modified Files
- `cmd/server/main.go` - Complete application initialization with database connection, migrations, server startup, and graceful shutdown handling
- `go.mod` - Added github.com/gin-contrib/cors v1.7.6 for CORS middleware

### API Specifications Updated
No API specification updates needed for this task (health endpoint is internal infrastructure).

## Notes

- Gin's default logger is replaced with our zerolog middleware
- Recovery middleware catches panics and returns 500 errors
- CORS settings may need adjustment for production (restrict origins)
- Health check provides simple way to verify server is running
- Graceful shutdown ensures requests complete before stopping
- Signal handling allows clean Ctrl+C shutdown in development
- Server timeouts prevent slow clients from holding connections
- Consider adding metrics endpoint in future (Prometheus)
- Consider adding readiness probe separate from liveness (health check)
- All previous tasks (config, logger, database, models) integrated here
- This completes PBI-1 with a running, functional web server

