# [1-4] Implement Configuration Management

[Back to task list](./tasks.md)

## Description

Implement a robust configuration management system using Viper that supports reading settings from configuration files (YAML/JSON), environment variables, and defaults. This provides flexible deployment options and eliminates hardcoded configuration values throughout the application.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-26 12:00:00 | Created | N/A | Proposed | Task file created | AI_Agent |
| 2025-10-27 21:55:00 | Status Change | Proposed | Agreed | Task approved for implementation | User |
| 2025-10-27 21:55:00 | Status Change | Agreed | InProgress | Started implementation | AI_Agent |
| 2025-10-27 21:57:00 | Status Change | InProgress | Review | Implementation completed, all verification tests passed | AI_Agent |
| 2025-10-27 23:35:00 | Minor Update | Review | Review | Added timeout validation and database connection timeout default | AI_Agent |
| 2025-10-27 23:36:00 | Status Change | Review | Done | Task approved and completed successfully | User |

## Requirements

### Functional Requirements
- Load configuration from YAML/JSON files
- Support environment variable overrides
- Provide sensible default values
- Validate configuration on load
- Expose configuration via a single Config struct
- Support different configs for development/production

### Configuration Parameters
- **Server Settings**
  - Port (default: 8080)
  - Host (default: "0.0.0.0")
  - Read timeout (default: 30s)
  - Write timeout (default: 30s)

- **Database Settings**
  - Database path (default: "./data/hermes.db")
  - Connection timeout
  - Enable WAL mode

- **Logging Settings**
  - Log level (default: "info")
  - Pretty print (default: false)

- **Media Settings**
  - Media library path (required, no default)
  - Supported formats

### Technical Requirements
- Use Viper for configuration management
- Environment variables prefixed with HERMES_ (e.g., HERMES_SERVER_PORT)
- Config file searched in: ./config.yaml, ./config.json, /etc/hermes/config.yaml
- All configuration values accessible via typed getters
- Configuration validation on startup

## Implementation Plan

### Step 1: Create Configuration Package Structure
- Create `internal/config/config.go`
- Define Config struct with all settings
- Create initialization function

### Step 2: Define Configuration Struct
```go
// internal/config/config.go
package config

import (
    "time"
)

const (
    defaultServerPort      = 8080
    defaultServerHost      = "0.0.0.0"
    defaultReadTimeout     = 30 * time.Second
    defaultWriteTimeout    = 30 * time.Second
    defaultDatabasePath    = "./data/hermes.db"
    defaultLogLevel        = "info"
    defaultLogPretty       = false
)

type Config struct {
    Server   ServerConfig
    Database DatabaseConfig
    Logging  LoggingConfig
    Media    MediaConfig
}

type ServerConfig struct {
    Port         int
    Host         string
    ReadTimeout  time.Duration
    WriteTimeout time.Duration
}

type DatabaseConfig struct {
    Path            string
    ConnectionTimeout time.Duration
    EnableWAL       bool
}

type LoggingConfig struct {
    Level  string
    Pretty bool
}

type MediaConfig struct {
    LibraryPath      string
    SupportedFormats []string
}
```

### Step 3: Implement Configuration Loading with Viper
```go
func Load() (*Config, error) {
    v := viper.New()
    
    // Set defaults
    setDefaults(v)
    
    // Config file settings
    v.SetConfigName("config")
    v.SetConfigType("yaml")
    v.AddConfigPath(".")
    v.AddConfigPath("./config")
    v.AddConfigPath("/etc/hermes")
    
    // Environment variable settings
    v.SetEnvPrefix("HERMES")
    v.AutomaticEnv()
    v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
    
    // Read config file (optional)
    if err := v.ReadInConfig(); err != nil {
        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {
            return nil, fmt.Errorf("error reading config: %w", err)
        }
        // Config file not found is OK, we'll use defaults and env vars
    }
    
    // Unmarshal into struct
    var cfg Config
    if err := v.Unmarshal(&cfg); err != nil {
        return nil, fmt.Errorf("error unmarshaling config: %w", err)
    }
    
    // Validate
    if err := cfg.Validate(); err != nil {
        return nil, fmt.Errorf("invalid configuration: %w", err)
    }
    
    return &cfg, nil
}

func setDefaults(v *viper.Viper) {
    v.SetDefault("server.port", defaultServerPort)
    v.SetDefault("server.host", defaultServerHost)
    v.SetDefault("server.readtimeout", defaultReadTimeout)
    v.SetDefault("server.writetimeout", defaultWriteTimeout)
    v.SetDefault("database.path", defaultDatabasePath)
    v.SetDefault("database.enablewal", true)
    v.SetDefault("logging.level", defaultLogLevel)
    v.SetDefault("logging.pretty", defaultLogPretty)
    v.SetDefault("media.supportedformats", []string{"mp4", "mkv", "avi", "mov"})
}
```

### Step 4: Add Configuration Validation
```go
func (c *Config) Validate() error {
    // Validate server port
    if c.Server.Port < 1 || c.Server.Port > 65535 {
        return fmt.Errorf("invalid server port: %d", c.Server.Port)
    }
    
    // Validate log level
    validLevels := []string{"debug", "info", "warn", "error"}
    if !contains(validLevels, c.Logging.Level) {
        return fmt.Errorf("invalid log level: %s", c.Logging.Level)
    }
    
    // Database path validation will be done when opening DB
    
    return nil
}

func contains(slice []string, item string) bool {
    for _, s := range slice {
        if s == item {
            return true
        }
    }
    return false
}
```

### Step 5: Create Sample Configuration Files
- Create `config.yaml.example` with all options documented
- Include comments explaining each setting
- Provide both development and production examples

### Step 6: Update main.go
- Load configuration at startup
- Pass config to logger and other components
- Log configuration values (excluding sensitive data)

### Step 7: Document Configuration
- Update README with configuration section
- List all available config options
- Show examples of environment variables

## Test Plan

This task involves configuration setup with verification of various config sources.

### Success Criteria
1. Configuration loads from YAML file
2. Configuration loads from environment variables
3. Environment variables override file settings
4. Default values used when not specified
5. Invalid configuration triggers validation errors
6. All config values accessible and correct type

### Test Scenarios

**Scenario 1: Default Configuration**
- No config file, no env vars
- Should use all default values
- Should load without errors

**Scenario 2: File Configuration**
- Create config.yaml with custom values
- Should load values from file
- Should override defaults

**Scenario 3: Environment Variable Override**
```bash
export HERMES_SERVER_PORT=9090
export HERMES_LOGGING_LEVEL=debug
go run ./cmd/server
# Should use port 9090 and debug logging
```

**Scenario 4: Validation**
- Set invalid port (0 or 70000)
- Set invalid log level ("invalid")
- Should return validation errors

### Manual Verification
```bash
# Test with config file
echo "server:
  port: 3000
logging:
  level: debug" > config.yaml
go run ./cmd/server

# Test with environment variables
HERMES_SERVER_PORT=4000 HERMES_LOGGING_LEVEL=warn go run ./cmd/server

# Test validation (should fail)
HERMES_SERVER_PORT=99999 go run ./cmd/server
```

## Verification

### Acceptance Criteria
- [ ] Config package created in internal/config/
- [ ] Config struct defined with all required settings
- [ ] Viper integration implemented
- [ ] Configuration loads from YAML files
- [ ] Environment variables override file settings
- [ ] Default values provided for all optional settings
- [ ] Configuration validation implemented
- [ ] Invalid configuration rejected with clear error messages
- [ ] config.yaml.example file created with documentation
- [ ] README updated with configuration documentation
- [ ] Configuration accessible in main.go

### Definition of Done
- All acceptance criteria met
- Configuration system works with files, env vars, and defaults
- Validation prevents invalid configurations
- Documentation complete and accurate

## Files Modified

### New Files Created
- `api/internal/config/config.go` - Configuration management package with Load(), Validate(), and default values
- `api/config.yaml.example` - Comprehensive example configuration file with documentation
- `api/go.mod` - Added github.com/joho/godotenv v1.5.1 dependency

### Modified Files
- `api/cmd/server/main.go` - Integrated config.Load() and removed hardcoded constants
- `docs/api-specs/infrastructure/infrastructure-api.md` - Added Configuration Management section with full documentation

### API Specifications Updated
- `docs/api-specs/infrastructure/infrastructure-api.md` - Documented config package, structs, environment variables, and usage examples

## Notes

- Viper automatically handles type conversion (string to int, duration, etc.)
- Environment variable names use underscores: `HERMES_SERVER_PORT`
- Config file is optional; app can run with just env vars and defaults
- Sensitive values (API keys, passwords) should come from env vars, not files
- Consider adding config reload capability in future for runtime updates
- Database path should be created if it doesn't exist

