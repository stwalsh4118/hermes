# [1-5] Create Database Schema and Migrations

[Back to task list](./tasks.md)

## Description

Create the complete SQLite database schema for the Virtual TV Channel Service using golang-migrate. This includes defining all tables (channels, media, playlist_items, settings) with proper data types, constraints, indexes, and foreign key relationships. UUIDs will be used for all primary keys.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-26 12:00:00 | Created | N/A | Proposed | Task file created | AI_Agent |
| 2025-10-27 22:15:00 | Status Change | Proposed | Agreed | Task approved for implementation | User |
| 2025-10-27 22:16:00 | Status Change | Agreed | InProgress | Started implementation | AI_Agent |
| 2025-10-27 22:20:00 | Status Change | InProgress | Review | Implementation completed, ready for review | AI_Agent |
| 2025-10-27 22:25:00 | Status Change | Review | Done | Task approved and completed successfully | User |

## Requirements

### Functional Requirements
- Create migration files for all four tables
- Use UUIDs (TEXT format) for all primary keys
- Implement proper foreign key constraints with CASCADE delete
- Add indexes for frequently queried columns
- Support both up and down migrations
- Enable SQLite foreign key constraints
- Use appropriate data types matching the PRD

### Database Tables

**1. channels**
- id (TEXT PRIMARY KEY) - UUID
- name (TEXT NOT NULL)
- icon (TEXT) - URL or path to icon
- start_time (DATETIME NOT NULL) - When channel started broadcasting
- loop (BOOLEAN NOT NULL DEFAULT 0) - Loop playlist when finished
- created_at (DATETIME DEFAULT CURRENT_TIMESTAMP)
- updated_at (DATETIME DEFAULT CURRENT_TIMESTAMP)

**2. media**
- id (TEXT PRIMARY KEY) - UUID
- file_path (TEXT NOT NULL UNIQUE) - Full path to media file
- title (TEXT NOT NULL) - Display title
- show_name (TEXT) - Series name
- season (INTEGER) - Season number
- episode (INTEGER) - Episode number
- duration (INTEGER NOT NULL) - Duration in seconds
- video_codec (TEXT) - e.g., "h264"
- audio_codec (TEXT) - e.g., "aac"
- resolution (TEXT) - e.g., "1920x1080"
- file_size (INTEGER) - Size in bytes
- created_at (DATETIME DEFAULT CURRENT_TIMESTAMP)

**3. playlist_items**
- id (TEXT PRIMARY KEY) - UUID
- channel_id (TEXT NOT NULL) - Foreign key to channels
- media_id (TEXT NOT NULL) - Foreign key to media
- position (INTEGER NOT NULL) - Order in playlist (0-indexed)
- created_at (DATETIME DEFAULT CURRENT_TIMESTAMP)
- FOREIGN KEY (channel_id) REFERENCES channels(id) ON DELETE CASCADE
- FOREIGN KEY (media_id) REFERENCES media(id) ON DELETE CASCADE
- UNIQUE (channel_id, position) - Ensure no duplicate positions

**4. settings**
- id (INTEGER PRIMARY KEY DEFAULT 1) - Single row table
- media_library_path (TEXT NOT NULL) - Path to media directory
- transcode_quality (TEXT DEFAULT 'medium') - high/medium/low
- hardware_accel (TEXT DEFAULT 'none') - none/nvenc/qsv/vaapi/videotoolbox
- server_port (INTEGER DEFAULT 8080)
- updated_at (DATETIME DEFAULT CURRENT_TIMESTAMP)
- CHECK (id = 1) - Enforce single row

### Indexes Required
- media(show_name, season, episode) - For efficient series queries
- playlist_items(channel_id, position) - For playlist ordering
- media(file_path) - Already unique, enforced by index

### Technical Requirements
- Use golang-migrate for migrations
- Migrations numbered sequentially (000001, 000002, etc.)
- Each migration has .up.sql and .down.sql files
- SQLite PRAGMA settings configured (foreign_keys=ON, journal_mode=WAL)
- All timestamps in UTC
- Boolean stored as INTEGER (0/1) per SQLite convention

## Implementation Plan

### Step 1: Install golang-migrate CLI (Optional)
```bash
# For local development and testing
go install -tags 'sqlite3' github.com/golang-migrate/migrate/v4/cmd/migrate@latest
```

### Step 2: Create Migration Directory Structure
```
migrations/
├── 000001_initial_schema.up.sql
└── 000001_initial_schema.down.sql
```

### Step 3: Create Up Migration (000001_initial_schema.up.sql)
```sql
-- Enable foreign key support
PRAGMA foreign_keys = ON;

-- Enable WAL mode for better concurrency
PRAGMA journal_mode = WAL;

-- Create channels table
CREATE TABLE IF NOT EXISTS channels (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    icon TEXT,
    start_time DATETIME NOT NULL,
    loop INTEGER NOT NULL DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Create media table
CREATE TABLE IF NOT EXISTS media (
    id TEXT PRIMARY KEY,
    file_path TEXT NOT NULL UNIQUE,
    title TEXT NOT NULL,
    show_name TEXT,
    season INTEGER,
    episode INTEGER,
    duration INTEGER NOT NULL,
    video_codec TEXT,
    audio_codec TEXT,
    resolution TEXT,
    file_size INTEGER,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Create index for media queries
CREATE INDEX IF NOT EXISTS idx_media_show ON media(show_name, season, episode);
CREATE INDEX IF NOT EXISTS idx_media_path ON media(file_path);

-- Create playlist_items table
CREATE TABLE IF NOT EXISTS playlist_items (
    id TEXT PRIMARY KEY,
    channel_id TEXT NOT NULL,
    media_id TEXT NOT NULL,
    position INTEGER NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (channel_id) REFERENCES channels(id) ON DELETE CASCADE,
    FOREIGN KEY (media_id) REFERENCES media(id) ON DELETE CASCADE,
    UNIQUE (channel_id, position)
);

-- Create index for playlist queries
CREATE INDEX IF NOT EXISTS idx_playlist_channel_pos ON playlist_items(channel_id, position);

-- Create settings table (single row)
CREATE TABLE IF NOT EXISTS settings (
    id INTEGER PRIMARY KEY DEFAULT 1,
    media_library_path TEXT NOT NULL,
    transcode_quality TEXT DEFAULT 'medium',
    hardware_accel TEXT DEFAULT 'none',
    server_port INTEGER DEFAULT 8080,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    CHECK (id = 1)
);

-- Insert default settings row
INSERT OR IGNORE INTO settings (id, media_library_path) 
VALUES (1, './media');
```

### Step 4: Create Down Migration (000001_initial_schema.down.sql)
```sql
-- Drop tables in reverse order (respecting foreign keys)
DROP TABLE IF EXISTS playlist_items;
DROP TABLE IF EXISTS media;
DROP TABLE IF EXISTS channels;
DROP TABLE IF EXISTS settings;
```

### Step 5: Create Migration Helper in Go
- Create `internal/db/migrations.go`
- Function to run migrations programmatically
- Integrate with golang-migrate library

```go
// internal/db/migrations.go
package db

import (
    "database/sql"
    "fmt"
    
    "github.com/golang-migrate/migrate/v4"
    "github.com/golang-migrate/migrate/v4/database/sqlite3"
    "github.com/golang-migrate/migrate/v4/source/file"
)

func RunMigrations(db *sql.DB, migrationsPath string) error {
    driver, err := sqlite3.WithInstance(db, &sqlite3.Config{})
    if err != nil {
        return fmt.Errorf("failed to create migration driver: %w", err)
    }
    
    sourceDriver, err := (&file.File{}).Open(migrationsPath)
    if err != nil {
        return fmt.Errorf("failed to open migrations: %w", err)
    }
    
    m, err := migrate.NewWithInstance(
        "file",
        sourceDriver,
        "sqlite3",
        driver,
    )
    if err != nil {
        return fmt.Errorf("failed to create migration instance: %w", err)
    }
    
    if err := m.Up(); err != nil && err != migrate.ErrNoChange {
        return fmt.Errorf("failed to run migrations: %w", err)
    }
    
    return nil
}
```

### Step 6: Test Migrations
- Create test database
- Run migrations up
- Verify tables created
- Run migrations down
- Verify tables dropped
- Test migration repeatability

## Test Plan

This task involves database schema creation with verification of structure and constraints.

### Success Criteria
1. Migration files created and properly formatted
2. Up migration creates all tables with correct schema
3. Down migration removes all tables cleanly
4. Foreign key constraints work correctly
5. Unique constraints enforced
6. Indexes created successfully
7. Settings table restricted to single row
8. Migrations are idempotent (can run multiple times safely)

### Test Scenarios

**Test 1: Run Up Migration**
```bash
# Using migrate CLI
migrate -path migrations -database "sqlite3://./test.db" up

# Verify schema
sqlite3 test.db ".schema"
```

**Test 2: Verify Foreign Key Constraints**
```sql
-- Should fail: referencing non-existent channel
INSERT INTO playlist_items (id, channel_id, media_id, position)
VALUES ('test-id', 'nonexistent', 'media-id', 0);

-- Should succeed after creating channel
INSERT INTO channels (id, name, start_time, loop)
VALUES ('chan-1', 'Test Channel', datetime('now'), 0);

INSERT INTO media (id, file_path, title, duration)
VALUES ('media-1', '/test.mp4', 'Test Video', 300);

INSERT INTO playlist_items (id, channel_id, media_id, position)
VALUES ('pl-1', 'chan-1', 'media-1', 0);

-- Should cascade delete
DELETE FROM channels WHERE id = 'chan-1';
SELECT COUNT(*) FROM playlist_items WHERE channel_id = 'chan-1'; -- Should be 0
```

**Test 3: Verify Unique Constraints**
```sql
-- Should fail: duplicate position in same channel
INSERT INTO playlist_items (id, channel_id, media_id, position)
VALUES ('pl-2', 'chan-1', 'media-1', 0);
```

**Test 4: Run Down Migration**
```bash
migrate -path migrations -database "sqlite3://./test.db" down
# Verify all tables removed
sqlite3 test.db ".tables"
```

**Test 5: Settings Single Row**
```sql
-- Should fail: only one settings row allowed
INSERT INTO settings (id, media_library_path) VALUES (2, '/media');
```

## Verification

### Acceptance Criteria
- [x] Migration directory created with proper structure
- [x] Up migration file creates all 4 tables
- [x] Down migration file drops all tables
- [x] All columns defined with correct types
- [x] UUID primary keys on channels, media, playlist_items
- [x] Foreign key constraints defined with CASCADE delete
- [x] Unique constraints on playlist_items(channel_id, position)
- [x] Indexes created for performance
- [x] Settings table limited to single row
- [x] Migration helper function created in Go
- [x] Up migration runs successfully
- [x] Down migration runs successfully
- [x] Migrations are idempotent

### Definition of Done
- All acceptance criteria met
- Schema matches PRD specifications exactly
- Foreign key constraints tested and working
- Migrations can be run multiple times safely
- Migration helper integrated with application

## Files Modified

### New Files Created
- `api/migrations/000001_initial_schema.up.sql` - Up migration with complete schema
- `api/migrations/000001_initial_schema.down.sql` - Down migration for rollback
- `api/internal/db/migrations.go` - Migration helper function

### Modified Files
- `docs/api-specs/infrastructure/infrastructure-api.md` - Added database migration documentation

## Notes

- SQLite stores booleans as INTEGER (0=false, 1=true)
- UUIDs stored as TEXT in format "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
- DATETIME stored as TEXT in ISO 8601 format
- WAL mode improves concurrent access performance
- Foreign keys must be explicitly enabled in SQLite with PRAGMA
- The settings table CHECK constraint ensures only row with id=1 exists
- Consider adding triggers for updated_at automatic updates in future
- Migration versioning allows rollback if needed

