# [6-3] Stream Session Types & Models

[Back to task list](./tasks.md)

## Description

Define data structures and types for managing active streaming sessions. This includes extending the existing `StreamSession` model, creating types for stream state management, and defining interfaces for session tracking. These types form the foundation for multi-client stream sharing, resource tracking, and lifecycle management. Thread-safe session tracking is critical for coordinating multiple clients watching the same channel.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-30 12:00:00 | Created | N/A | Proposed | Task file created | AI_Agent |

## Requirements

### Functional Requirements
- Extend existing StreamSession model with additional fields
- Thread-safe client connection tracking
- FFmpeg process lifecycle management
- Stream state tracking (starting, active, stopping, failed)
- Last access time tracking for cleanup decisions
- Quality variant tracking for ABR streams
- Error state capture for recovery decisions

### Technical Requirements
- Extend `api/internal/models/stream_session.go`
- Create `api/internal/streaming/types.go` for streaming-specific types
- Use `sync.RWMutex` for thread-safe operations
- Follow existing model patterns in the project
- Use appropriate Go types (uuid.UUID, time.Time, atomic operations)

### Data Structures Required

**StreamSession (Extended):**
- Existing fields from `models/stream_session.go`
- `State` - Current stream state
- `Quality` - Quality variants being generated
- `LastAccessTime` - When last client interacted
- `ErrorCount` - Number of errors encountered
- `LastError` - Most recent error message
- `SegmentPath` - Directory where segments are stored
- `OutputDir` - Base directory for stream output

**StreamState:**
- `StateStarting` - FFmpeg process launching
- `StateActive` - Stream running, generating segments
- `StateStopping` - Graceful shutdown in progress
- `StateFailed` - Stream failed, needs recovery
- `StateIdle` - No active stream

**StreamQuality:**
- Quality level information for each variant
- Bitrate, resolution, codec information
- Segment and playlist file paths

## Implementation Plan

### Step 1: Define StreamState enum
- Create `api/internal/streaming/types.go`
- Define StreamState type and constants
- Add state transition validation logic

### Step 2: Define StreamQuality struct
```go
type StreamQuality struct {
    Level       string // "1080p", "720p", "480p"
    Bitrate     int    // Video bitrate in kbps
    Resolution  string // "1920x1080"
    SegmentPath string // Path to segments
    PlaylistPath string // Path to .m3u8 file
}
```

### Step 3: Extend StreamSession model
- Add new fields to existing `models/stream_session.go`
- Add methods for state management
- Add methods for client tracking (already partially exists)
- Add methods for error tracking
- Ensure thread-safety with mutex

### Step 4: Add session management methods
```go
// State management
func (s *StreamSession) GetState() StreamState
func (s *StreamSession) SetState(state StreamState)
func (s *StreamSession) CanTransitionTo(newState StreamState) bool

// Client management (extend existing)
func (s *StreamSession) IncrementClients()  // Existing
func (s *StreamSession) DecrementClients()  // Existing
func (s *StreamSession) GetClientCount() int // Existing
func (s *StreamSession) UpdateLastAccess()

// Error management
func (s *StreamSession) IncrementErrorCount()
func (s *StreamSession) GetErrorCount() int
func (s *StreamSession) SetLastError(err error)
func (s *StreamSession) GetLastError() string

// Quality management
func (s *StreamSession) SetQualities(qualities []StreamQuality)
func (s *StreamSession) GetQualities() []StreamQuality

// Cleanup decision support
func (s *StreamSession) IdleDuration() time.Duration
func (s *StreamSession) ShouldCleanup(gracePeriod time.Duration) bool
```

### Step 5: Add session collection type
```go
type SessionManager struct {
    sessions map[uuid.UUID]*StreamSession
    mu       sync.RWMutex
}

func NewSessionManager() *SessionManager
func (m *SessionManager) Get(channelID uuid.UUID) (*StreamSession, bool)
func (m *SessionManager) Set(channelID uuid.UUID, session *StreamSession)
func (m *SessionManager) Delete(channelID uuid.UUID)
func (m *SessionManager) List() []*StreamSession
```

### Step 6: Add validation and documentation
- Document all exported types and methods
- Add JSON tags for potential debugging endpoints
- Validate state transitions
- Add example usage in comments

## Test Plan

### Objective
Verify data structures support thread-safe session management and provide all necessary fields for stream lifecycle.

### Test Scope
- Thread-safe client counting
- State transition validation
- Error tracking
- Session collection operations
- Cleanup decision logic

### Key Test Scenarios

**Unit Tests:**
1. **Client counting** - Concurrent increment/decrement operations
2. **State transitions** - Valid and invalid transitions
3. **Error tracking** - Error count and message capture
4. **Last access tracking** - Idle duration calculations
5. **Cleanup decisions** - Grace period logic
6. **SessionManager operations** - Concurrent get/set/delete
7. **Quality variant management** - Multiple quality tracking

**Concurrency Tests:**
- Multiple goroutines incrementing/decrementing clients
- Concurrent state reads during writes
- Race detector enabled tests

### Success Criteria
- All unit tests pass
- No race conditions detected
- Thread-safe operations verified
- State transitions properly validated
- Cleanup logic correctly determines eligibility
- Data structures match requirements

## Verification

### Acceptance Criteria
- [ ] StreamState enum defined with all required states
- [ ] StreamQuality struct created with necessary fields
- [ ] StreamSession extended with new fields
- [ ] All session management methods implemented
- [ ] Thread-safety ensured with proper mutex usage
- [ ] SessionManager provides concurrent-safe collection operations
- [ ] State transition validation prevents invalid transitions
- [ ] Cleanup decision logic correctly implemented
- [ ] JSON tags added for debugging support
- [ ] All exported types and methods documented
- [ ] Unit tests achieve >90% coverage
- [ ] Race detector tests pass
- [ ] Code compiles without errors
- [ ] No linter warnings

### Definition of Done
- All acceptance criteria met
- Comprehensive unit tests including concurrency tests
- Race detector enabled tests pass
- Code follows Go concurrency best practices
- Documentation complete
- Ready for integration with Stream Manager Service

## Files Modified

### Modified Files
- `api/internal/models/stream_session.go` - Extend StreamSession with new fields and methods

### New Files Created
- `api/internal/streaming/types.go` - StreamState, StreamQuality, SessionManager
- `api/internal/streaming/types_test.go` - Unit and concurrency tests

### API Specifications Updated
- `docs/api-specs/streaming/streaming-api.md` - Document stream session structure and state machine

## Notes

- StreamSession already exists in the codebase with basic structure
- This task extends it rather than creating from scratch
- Thread-safety is critical - all mutations must be protected
- Consider using atomic operations for simple counters
- State machine should prevent invalid transitions
- Last access time enables intelligent cleanup decisions
- Error tracking supports recovery and restart logic
- SessionManager can be used later for monitoring endpoints
- Reference existing `models/stream_session.go` for current structure
- No database persistence - sessions are in-memory only

