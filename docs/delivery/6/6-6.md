# [6-6] Timeline Position to FFmpeg Input

[Back to task list](./tasks.md)

## Description

Implement the integration layer between the Timeline Service and FFmpeg streaming. This task handles converting a channel's current timeline position into proper FFmpeg input parameters, including seeking to the correct position within media files, handling playlist item transitions, and potentially concatenating multiple files for continuous playback. This is crucial for ensuring streams start at the exact correct position in the channel's virtual timeline.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-30 12:00:00 | Created | N/A | Proposed | Task file created | AI_Agent |
| 2025-10-31 19:30:00 | Status Change | Proposed | InProgress | Started implementation | AI_Agent |
| 2025-10-31 19:45:00 | Status Change | InProgress | Review | Implementation complete, all tests passing | AI_Agent |
| 2025-10-31 20:00:00 | Status Change | Review | Done | Approved, all quality checks passed | User |

## Requirements

### Functional Requirements
- Calculate FFmpeg input parameters from timeline position
- Seek to correct offset within current media file
- Handle transitions between playlist items seamlessly
- Support concatenation of multiple files for continuous streaming
- Calculate remaining duration of current media item
- Prepare next playlist items for smooth transitions
- Handle edge cases (file ends, playlist loops, single long files)

### Technical Requirements
- Create `api/internal/streaming/timeline_input.go`
- Integrate with Timeline Service (existing)
- Use FFmpeg concat protocol for multi-file inputs
- Generate FFmpeg-compatible seek parameters
- No direct FFmpeg execution (command building only)
- Pure functions where possible for testability

### FFmpeg Input Scenarios

**Scenario 1: Simple seek into single file**
```bash
ffmpeg -ss 120 -i /path/to/video.mp4 ...
```

**Scenario 2: Concat protocol for continuous playback**
```bash
# concat.txt:
file '/path/to/video1.mp4'
inpoint 120
file '/path/to/video2.mp4'
file '/path/to/video3.mp4'

ffmpeg -f concat -safe 0 -i concat.txt ...
```

**Scenario 3: Near end of file - prepare next item**
```bash
# Include current file from offset + next files
```

## Implementation Plan

### Step 1: Define input builder types
```go
type TimelineInput struct {
    PrimaryFile    string  // Main input file
    SeekSeconds    int64   // Seek position in primary file
    ConcatFiles    []ConcatItem // Additional files for continuous play
    TotalDuration  int64   // Total duration to stream
}

type ConcatItem struct {
    FilePath    string
    InPoint     int64  // Start time within file (seconds)
    OutPoint    int64  // End time within file (0 = use all)
}
```

### Step 2: Implement main conversion function
```go
func BuildTimelineInput(
    ctx context.Context,
    channelID uuid.UUID,
    timelineService *timeline.TimelineService,
    repos *db.Repositories,
) (*TimelineInput, error)
```

Steps:
1. Get current timeline position from Timeline Service
2. Get channel and playlist from repositories
3. Calculate remaining duration of current item
4. Determine if concat needed (near end of item)
5. Build input structure with seek position
6. Include next N playlist items if needed

### Step 3: Implement concat file builder
```go
func BuildConcatFile(items []ConcatItem, outputPath string) error
```

- Generate concat demuxer format file
- Include file paths and inpoint/outpoint directives
- Write to temporary location
- Return path to concat file

### Step 4: Implement duration calculations
```go
func CalculateStreamDuration(
    currentItem *models.PlaylistItem,
    offsetSeconds int64,
    nextItems []*models.PlaylistItem,
) int64
```

- Calculate remaining time in current item
- Add duration of subsequent items
- Limit total duration (e.g., max 2 hours)
- Account for playlist looping

### Step 5: Implement playlist item fetching
```go
func GetNextPlaylistItems(
    ctx context.Context,
    channelID uuid.UUID,
    currentPosition int,
    count int,
    repos *db.Repositories,
) ([]*models.PlaylistItem, error)
```

- Fetch next N items from playlist
- Handle playlist end (loop or stop)
- Include media information for each item

### Step 6: Add seek optimization
- For seeks near file start (<10s), skip seeking (faster start)
- For seeks near file end, use concat with next file
- Optimize for startup time vs accuracy trade-off

### Step 7: Add validation and error handling
- Validate all media files exist
- Check file paths are absolute
- Handle missing files gracefully
- Validate seek positions are within bounds

## Test Plan

### Objective
Verify timeline position correctly translates to FFmpeg input parameters for all scenarios.

### Test Scope
- Simple seek within single file
- Concat file generation for multiple items
- Duration calculations
- Playlist item fetching with looping
- Edge cases (start of file, end of file, playlist boundaries)

### Key Test Scenarios

**Unit Tests:**
1. **Seek to middle of file** - Single file with seek offset
2. **Near start of file** - No seek applied (optimization)
3. **Near end of file** - Concat with next file
4. **Multiple playlist items** - Concat file with 3+ items
5. **Playlist loop** - Wraps to first item correctly
6. **Single item playlist** - Handles looping single item
7. **Last item non-looping** - Handles playlist end
8. **Duration calculation** - Correct total duration
9. **Missing file** - Returns appropriate error
10. **Invalid seek position** - Validates and adjusts

**Integration Tests:**
- Build input from real timeline position
- Generate concat file and verify format
- Validate with actual FFmpeg (can it parse it?)
- Test with various channel configurations

**Edge Cases:**
- Seek beyond file duration
- Empty playlist (should not happen, but handle gracefully)
- Corrupt media file
- Very long files (hours long)
- Very short files (<1 second)

### Success Criteria
- Correct seek positions calculated
- Concat files are FFmpeg-compatible
- Playlist transitions are seamless
- Duration calculations are accurate
- Edge cases handled gracefully
- Performance acceptable (<50ms per calculation)

## Verification

### Acceptance Criteria
- [x] BuildTimelineInput converts timeline position to FFmpeg input
- [x] Seek positions correctly calculated from timeline offset
- [x] Concat file generation works for multiple items
- [x] Duration calculations account for current offset and next items
- [x] Playlist item fetching handles looping correctly
- [x] Optimization skips seeking for positions near start
- [x] Near-end positions trigger concat with next item
- [x] File existence validation before returning input
- [x] Error handling for missing or invalid files
- [x] Integration with Timeline Service works correctly
- [x] Unit test coverage: 67.3% (BuildTimelineInput covered by integration tests)
- [x] Integration tests with Timeline Service pass
- [x] Generated concat files are FFmpeg-compatible
- [x] Code compiles without errors
- [x] No linter warnings

### Definition of Done
- All acceptance criteria met
- Comprehensive unit tests
- Integration tests with Timeline Service
- Validated with actual FFmpeg (concat files work)
- Code follows Go best practices
- Performance benchmarks meet targets
- Ready for Stream Manager integration

## Files Modified

### New Files Created
- `api/internal/streaming/timeline_input.go` - Timeline to FFmpeg input conversion (335 lines)
- `api/internal/streaming/timeline_input_test.go` - Comprehensive unit tests (565 lines)
- `api/test/integration/timeline_input_integration_test.go` - Integration tests (318 lines)

### API Specifications Updated
- `docs/api-specs/streaming/streaming-api.md` - Added complete timeline input API documentation (344 lines added)

## Notes

- This bridges the virtual timeline with actual video files
- Accuracy is critical - wrong seek = wrong content
- FFmpeg concat protocol is powerful but requires specific format
- Consider startup time vs accuracy trade-offs
- Near-start seeks can be skipped for faster startup
- Near-end seeks should include next file for seamless transition
- Concat file should be temporary and cleaned up
- File paths must be absolute or relative to concat file location
- Consider disk I/O performance for concat file writes
- Future: Support for mid-stream quality switching
- Future: Support for seeking in concatenated streams
- Integration point with Timeline Service must be clean
- May need to handle Timeline Service errors (empty playlist, etc.)
- Consider caching recent timeline calculations to avoid repeated lookups

