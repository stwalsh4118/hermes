# [6-8] Error Handling & Recovery

[Back to task list](./tasks.md)

## Description

Implement comprehensive error handling and recovery mechanisms for the streaming engine. This includes detecting and recovering from FFmpeg crashes, handling missing or corrupted video files, implementing fallback from hardware to software encoding, managing disk space issues, and ensuring the system degrades gracefully under error conditions. Robust error handling is critical for a reliable streaming service.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-30 12:00:00 | Created | N/A | Proposed | Task file created | AI_Agent |

## Requirements

### Functional Requirements
- Detect FFmpeg process crashes and failures
- Attempt automatic restart after crashes (with limits)
- Handle missing or corrupted video files gracefully
- Skip to next playlist item when current file fails
- Fallback to software encoding when hardware fails
- Detect and handle disk space exhaustion
- Implement circuit breaker pattern for repeated failures
- Log all errors with context for debugging
- Notify clients of stream failures appropriately

### Technical Requirements
- Extend Stream Manager with recovery logic
- Create error detection and classification system
- Implement retry logic with exponential backoff
- Add circuit breaker for repeated failures
- Monitor FFmpeg stderr for error messages
- Check disk space before starting streams
- Add health check indicators
- Follow Go error handling best practices

### Error Categories

**Critical Errors (Stop Stream):**
- Disk space exhausted
- All media files corrupt or missing
- Hardware failure with no fallback available
- Too many consecutive failures (circuit breaker trips)

**Recoverable Errors (Retry):**
- FFmpeg crash (transient issue)
- Single file missing or corrupt (skip to next)
- Hardware encoder failure (fallback to software)
- Temporary I/O error

**Expected Errors (Handle Gracefully):**
- Playlist end (non-looping channel)
- Timeline calculation errors (channel not started)

## Implementation Plan

### Step 1: Implement error classification
```go
type StreamError struct {
    Type       ErrorType
    Severity   ErrorSeverity
    Message    string
    Cause      error
    Recoverable bool
}

type ErrorType int
const (
    ErrorFFmpegCrash ErrorType = iota
    ErrorFileMissing
    ErrorFileCorrupt
    ErrorHardwareEncoder
    ErrorDiskSpace
    ErrorPlaylistEnd
    ErrorTimeout
)

type ErrorSeverity int
const (
    SeverityInfo ErrorSeverity = iota
    SeverityWarning
    SeverityError
    SeverityCritical
)
```

### Step 2: Implement FFmpeg crash detection
```go
func (m *StreamManager) monitorFFmpegProcess(session *StreamSession) error
```

- Monitor FFmpeg process exit code
- Capture stderr output
- Parse error messages for classification
- Detect common failure patterns
- Return structured error information

### Step 3: Implement automatic restart logic
```go
func (m *StreamManager) restartStream(
    ctx context.Context,
    channelID uuid.UUID,
    reason string,
) error
```

Steps:
1. Check restart count (max 3 attempts)
2. Increment error count on session
3. Wait with exponential backoff (1s, 2s, 4s)
4. Clean up failed stream resources
5. Attempt to restart stream
6. Reset error count on success
7. Trip circuit breaker if max attempts exceeded

### Step 4: Implement file error handling
```go
func (m *StreamManager) handleFileError(
    ctx context.Context,
    session *StreamSession,
    filePath string,
) error
```

Steps:
1. Log file error with path
2. Get next playlist item
3. Update timeline position to next item
4. Rebuild FFmpeg command with new file
5. Restart stream with new input
6. Return error if no more items

### Step 5: Implement hardware fallback
```go
func (m *StreamManager) fallbackToSoftwareEncoding(
    ctx context.Context,
    session *StreamSession,
) error
```

Steps:
1. Detect hardware encoder failure from FFmpeg stderr
2. Log fallback event
3. Rebuild command with software encoding
4. Update session with new encoding method
5. Restart stream
6. Update configuration for future streams

### Step 6: Implement disk space checks
```go
func (m *StreamManager) checkDiskSpace(path string) error
```

- Check available disk space before starting stream
- Require minimum space (e.g., 5GB)
- Return error if insufficient
- Periodically check during streaming
- Trigger cleanup if space low

### Step 7: Implement circuit breaker
```go
type CircuitBreaker struct {
    failureThreshold int
    resetTimeout     time.Duration
    state            CircuitState
    failures         int
    lastFailure      time.Time
    mu               sync.Mutex
}

func (cb *CircuitBreaker) Call(fn func() error) error
```

States: Closed (normal), Open (blocking calls), HalfOpen (testing recovery)

### Step 8: Add recovery metrics and logging
- Log all error events with structured data
- Track error counts per stream
- Track recovery attempts and success rate
- Expose metrics for monitoring (future)

## Test Plan

### Objective
Verify error handling correctly detects failures, attempts recovery when possible, and degrades gracefully when recovery fails.

### Test Scope
- FFmpeg crash detection and restart
- File error handling and skipping
- Hardware fallback to software
- Disk space checking
- Circuit breaker behavior
- Error classification
- Recovery attempt limits

### Key Test Scenarios

**Unit Tests (with mocks):**
1. **FFmpeg crash detection** - Process exit detected, error classified
2. **Automatic restart** - Stream restarts after crash
3. **Restart limit** - Circuit breaker trips after 3 failures
4. **Exponential backoff** - Wait times increase correctly
5. **File missing** - Skips to next playlist item
6. **Hardware failure** - Falls back to software encoding
7. **Disk space check** - Rejects stream start if insufficient
8. **Circuit breaker states** - Transitions work correctly

**Integration Tests:**
1. **Crash and recovery** - Kill FFmpeg, verify restart
2. **Missing file handling** - Remove file, verify skip to next
3. **Hardware fallback** - Simulate hardware failure, verify software works
4. **Multiple failures** - Verify circuit breaker trips
5. **Disk full simulation** - Verify graceful handling

**Error Injection Tests:**
- Use test doubles to inject various failure scenarios
- Verify recovery paths execute correctly
- Verify logging includes necessary context

### Success Criteria
- FFmpeg crashes are detected within 1 second
- Automatic restart succeeds for transient failures
- Circuit breaker prevents infinite restart loops
- File errors skip to next item without user intervention
- Hardware fallback enables continued streaming
- Disk space issues prevent startup
- All errors are logged with context
- Clients receive appropriate error responses

## Verification

### Acceptance Criteria
- [ ] FFmpeg process monitoring detects crashes
- [ ] Automatic restart attempts up to 3 times
- [ ] Exponential backoff between restart attempts
- [ ] Missing/corrupt files trigger skip to next item
- [ ] Hardware encoder failures fallback to software
- [ ] Disk space checked before stream start
- [ ] Circuit breaker trips after repeated failures
- [ ] Error classification identifies error types
- [ ] Structured logging includes all error context
- [ ] Recovery metrics tracked per stream
- [ ] Clients notified of stream failures appropriately
- [ ] Graceful degradation under error conditions
- [ ] Unit test coverage >85%
- [ ] Integration tests with real failures pass
- [ ] Error injection tests pass
- [ ] Code compiles without errors
- [ ] No linter warnings

### Definition of Done
- All acceptance criteria met
- Comprehensive unit tests with mocks
- Integration tests with real failure scenarios
- Error injection tests for all failure types
- Circuit breaker tested under load
- Logging verified for all error paths
- Code follows Go error handling best practices
- Recovery behavior documented
- Ready for production use

## Files Modified

### New Files Created
- `api/internal/streaming/errors.go` - Error types and classification
- `api/internal/streaming/recovery.go` - Recovery logic
- `api/internal/streaming/circuit_breaker.go` - Circuit breaker implementation
- `api/internal/streaming/errors_test.go` - Error handling tests

### Modified Files
- `api/internal/streaming/manager.go` - Add recovery methods
- `api/internal/streaming/process.go` - Add process monitoring

### API Specifications Updated
- `docs/api-specs/streaming/streaming-api.md` - Document error handling and recovery behavior

## Notes

- Error handling is as important as happy path for reliable service
- Logging must include enough context for debugging production issues
- Circuit breaker prevents cascading failures and resource exhaustion
- Exponential backoff prevents thundering herd during outages
- Hardware fallback ensures service continuity even with GPU issues
- File skipping is better than stopping entire stream for one bad file
- Disk space issues can corrupt databases, must detect early
- Consider alerting/notifications for critical errors (future)
- Error messages to clients should be user-friendly
- Structured logging enables log aggregation and analysis
- Recovery attempts should be bounded to prevent infinite loops
- Consider different retry strategies for different error types
- FFmpeg stderr parsing can be brittle, need robust patterns
- Test with various FFmpeg versions to ensure compatibility
- Future: Integrate with monitoring/alerting system
- Future: Machine learning for predictive failure detection
- Reference: Hystrix, Resilience4j for circuit breaker patterns

