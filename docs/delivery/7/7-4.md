# [7-4] Set up TanStack Query and API client layer

[Back to task list](./tasks.md)

## Description

Install and configure TanStack Query (React Query) v5 for server state management and data fetching. Create a type-safe API client layer that integrates with the Go backend, including proper error handling, request/response types, and query hooks for channels and media.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-27 14:00:00 | Created | N/A | Proposed | Task file created | AI_Agent |

## Requirements

### Functional Requirements
- Install and configure TanStack Query v5.85
- Create QueryClient with sensible defaults
- Create QueryClientProvider wrapper
- Build type-safe API client for backend communication
- Define TypeScript types matching backend models
- Create custom hooks for data fetching (useChannels, useMedia, etc.)
- Implement proper error handling
- Add request/response interceptors

### Technical Requirements
- TanStack Query v5.85
- API base URL configurable via environment variables
- Type-safe request/response handling
- Proper error types and handling
- DevTools integration for development

### API Endpoints to Support
- `GET /api/health` - Health check
- `GET /api/channels` - List all channels
- `GET /api/channels/:id` - Get single channel
- `POST /api/channels` - Create channel
- `PUT /api/channels/:id` - Update channel
- `DELETE /api/channels/:id` - Delete channel
- `GET /api/media` - List all media
- `GET /api/media/:id` - Get single media
- `POST /api/media/scan` - Scan media library

## Implementation Plan

### Step 1: Install TanStack Query
```bash
cd web
pnpm add @tanstack/react-query@5.85.0
pnpm add -D @tanstack/react-query-devtools
```

### Step 2: Create API Types
Create `lib/types/api.ts`:
```typescript
// Backend model types
export interface Channel {
  id: string;
  name: string;
  icon: string;
  start_time: string;
  loop: boolean;
  created_at: string;
  updated_at: string;
}

export interface Media {
  id: string;
  file_path: string;
  title: string;
  show_name: string;
  season?: number;
  episode?: number;
  duration: number;
  video_codec: string;
  audio_codec: string;
  resolution: string;
  file_size: number;
  created_at: string;
}

export interface PlaylistItem {
  id: string;
  channel_id: string;
  media_id: string;
  position: number;
  created_at: string;
}

// Request types
export interface CreateChannelRequest {
  name: string;
  icon: string;
  start_time: string;
  loop: boolean;
}

export interface UpdateChannelRequest {
  name?: string;
  icon?: string;
  start_time?: string;
  loop?: boolean;
}

export interface ScanMediaRequest {
  path: string;
}

// Response types
export interface ApiError {
  error: string;
  message: string;
  status: number;
}

export interface HealthResponse {
  status: string;
  timestamp: string;
}
```

### Step 3: Create API Client
Create `lib/api/client.ts`:
```typescript
import { ApiError } from "@/lib/types/api";

const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || "http://localhost:8080";

class ApiClient {
  private baseURL: string;

  constructor(baseURL: string) {
    this.baseURL = baseURL;
  }

  private async request<T>(
    endpoint: string,
    options?: RequestInit
  ): Promise<T> {
    const url = `${this.baseURL}${endpoint}`;
    
    const config: RequestInit = {
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
      },
    };

    try {
      const response = await fetch(url, config);

      if (!response.ok) {
        const error: ApiError = await response.json().catch(() => ({
          error: "Unknown Error",
          message: response.statusText,
          status: response.status,
        }));
        throw error;
      }

      return response.json();
    } catch (error) {
      if (error instanceof Error) {
        throw {
          error: "Network Error",
          message: error.message,
          status: 0,
        } as ApiError;
      }
      throw error;
    }
  }

  // Health check
  async health() {
    return this.request<{ status: string; timestamp: string }>("/api/health");
  }

  // Channel endpoints
  async getChannels() {
    return this.request<Channel[]>("/api/channels");
  }

  async getChannel(id: string) {
    return this.request<Channel>(`/api/channels/${id}`);
  }

  async createChannel(data: CreateChannelRequest) {
    return this.request<Channel>("/api/channels", {
      method: "POST",
      body: JSON.stringify(data),
    });
  }

  async updateChannel(id: string, data: UpdateChannelRequest) {
    return this.request<Channel>(`/api/channels/${id}`, {
      method: "PUT",
      body: JSON.stringify(data),
    });
  }

  async deleteChannel(id: string) {
    return this.request<void>(`/api/channels/${id}`, {
      method: "DELETE",
    });
  }

  // Media endpoints
  async getMedia() {
    return this.request<Media[]>("/api/media");
  }

  async getMediaItem(id: string) {
    return this.request<Media>(`/api/media/${id}`);
  }

  async scanMedia(path: string) {
    return this.request<{ message: string }>("/api/media/scan", {
      method: "POST",
      body: JSON.stringify({ path }),
    });
  }
}

export const apiClient = new ApiClient(API_BASE_URL);
```

### Step 4: Create Query Client Configuration
Create `lib/query/client.ts`:
```typescript
import { QueryClient, DefaultOptions } from "@tanstack/react-query";

const queryConfig: DefaultOptions = {
  queries: {
    staleTime: 1000 * 60 * 5, // 5 minutes
    gcTime: 1000 * 60 * 10, // 10 minutes (formerly cacheTime)
    refetchOnWindowFocus: false,
    retry: 1,
  },
};

export const queryClient = new QueryClient({ defaultOptions: queryConfig });
```

### Step 5: Create Query Provider
Create `components/providers/query-provider.tsx`:
```typescript
"use client";

import * as React from "react";
import { QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { queryClient } from "@/lib/query/client";

export function QueryProvider({ children }: { children: React.ReactNode }) {
  return (
    <QueryClientProvider client={queryClient}>
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
```

### Step 6: Update Root Layout
Update `app/layout.tsx`:
```typescript
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { ThemeProvider } from "@/components/providers/theme-provider";
import { QueryProvider } from "@/components/providers/query-provider";
import { Toaster } from "@/components/ui/sonner";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Hermes - Virtual TV Channel Service",
  description: "Manage and stream your own virtual TV channels",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={inter.className}>
        <ThemeProvider
          attribute="class"
          defaultTheme="system"
          enableSystem
          disableTransitionOnChange
        >
          <QueryProvider>
            {children}
          </QueryProvider>
          <Toaster />
        </ThemeProvider>
      </body>
    </html>
  );
}
```

### Step 7: Create Query Hooks
Create `hooks/use-channels.ts`:
```typescript
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiClient } from "@/lib/api/client";
import { CreateChannelRequest, UpdateChannelRequest } from "@/lib/types/api";
import { toast } from "sonner";

export const channelKeys = {
  all: ["channels"] as const,
  lists: () => [...channelKeys.all, "list"] as const,
  list: (filters: string) => [...channelKeys.lists(), { filters }] as const,
  details: () => [...channelKeys.all, "detail"] as const,
  detail: (id: string) => [...channelKeys.details(), id] as const,
};

export function useChannels() {
  return useQuery({
    queryKey: channelKeys.lists(),
    queryFn: () => apiClient.getChannels(),
  });
}

export function useChannel(id: string) {
  return useQuery({
    queryKey: channelKeys.detail(id),
    queryFn: () => apiClient.getChannel(id),
    enabled: !!id,
  });
}

export function useCreateChannel() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: CreateChannelRequest) => apiClient.createChannel(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: channelKeys.lists() });
      toast.success("Channel created successfully");
    },
    onError: (error: any) => {
      toast.error(error.message || "Failed to create channel");
    },
  });
}

export function useUpdateChannel(id: string) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: UpdateChannelRequest) => apiClient.updateChannel(id, data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: channelKeys.detail(id) });
      queryClient.invalidateQueries({ queryKey: channelKeys.lists() });
      toast.success("Channel updated successfully");
    },
    onError: (error: any) => {
      toast.error(error.message || "Failed to update channel");
    },
  });
}

export function useDeleteChannel() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) => apiClient.deleteChannel(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: channelKeys.lists() });
      toast.success("Channel deleted successfully");
    },
    onError: (error: any) => {
      toast.error(error.message || "Failed to delete channel");
    },
  });
}
```

Create `hooks/use-media.ts`:
```typescript
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiClient } from "@/lib/api/client";
import { toast } from "sonner";

export const mediaKeys = {
  all: ["media"] as const,
  lists: () => [...mediaKeys.all, "list"] as const,
  list: (filters: string) => [...mediaKeys.lists(), { filters }] as const,
  details: () => [...mediaKeys.all, "detail"] as const,
  detail: (id: string) => [...mediaKeys.details(), id] as const,
};

export function useMedia() {
  return useQuery({
    queryKey: mediaKeys.lists(),
    queryFn: () => apiClient.getMedia(),
  });
}

export function useMediaItem(id: string) {
  return useQuery({
    queryKey: mediaKeys.detail(id),
    queryFn: () => apiClient.getMediaItem(id),
    enabled: !!id,
  });
}

export function useScanMedia() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (path: string) => apiClient.scanMedia(path),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: mediaKeys.lists() });
      toast.success("Media scan started");
    },
    onError: (error: any) => {
      toast.error(error.message || "Failed to scan media");
    },
  });
}
```

### Step 8: Create Environment Variable File
Create `.env.local`:
```env
NEXT_PUBLIC_API_URL=http://localhost:8080
```

Update `.env.example`:
```env
NEXT_PUBLIC_API_URL=http://localhost:8080
```

### Step 9: Create API Test Page
Create `app/api-test/page.tsx`:
```typescript
"use client";

import { useChannels, useMedia } from "@/hooks/use-channels";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";

export default function ApiTestPage() {
  const { data: channels, isLoading: channelsLoading, error: channelsError } = useChannels();
  const { data: media, isLoading: mediaLoading, error: mediaError } = useMedia();

  return (
    <div className="container mx-auto py-10 space-y-8">
      <div>
        <h1 className="text-4xl font-bold mb-2">API Test</h1>
        <p className="text-muted-foreground">Testing API client and TanStack Query</p>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Channels</CardTitle>
        </CardHeader>
        <CardContent>
          {channelsLoading && <Skeleton className="h-20 w-full" />}
          {channelsError && (
            <div className="text-destructive">Error: {(channelsError as any).message}</div>
          )}
          {channels && (
            <pre className="text-sm bg-muted p-4 rounded">
              {JSON.stringify(channels, null, 2)}
            </pre>
          )}
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Media</CardTitle>
        </CardHeader>
        <CardContent>
          {mediaLoading && <Skeleton className="h-20 w-full" />}
          {mediaError && (
            <div className="text-destructive">Error: {(mediaError as any).message}</div>
          )}
          {media && (
            <pre className="text-sm bg-muted p-4 rounded">
              {JSON.stringify(media, null, 2)}
            </pre>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
```

### Step 10: Verify API Integration
- Start backend API server (must be running)
- Start frontend dev server
- Visit `/api-test` page
- Verify queries execute and data displays (or errors if backend not running)
- Check React Query DevTools in bottom-left corner
- Test query invalidation and refetching

## Test Plan

### Success Criteria
1. TanStack Query is properly configured
2. API client can communicate with backend
3. Query hooks work correctly
4. Mutations trigger invalidation
5. Error handling works
6. DevTools show query states
7. Type safety is maintained

### Manual Testing
1. **Without Backend Running**
   - Visit `/api-test`
   - Should see network error messages
   - DevTools should show failed queries

2. **With Backend Running**
   - Start backend API server
   - Visit `/api-test`
   - Should see channel and media data (or empty arrays)
   - DevTools should show successful queries

3. **Query Key Structure**
   - Open React Query DevTools
   - Verify query keys follow the defined structure
   - Check cache times and stale times

4. **Type Safety**
   - Run `pnpm type-check`
   - Verify no TypeScript errors

## Verification

### Acceptance Criteria
- [ ] TanStack Query v5.85 installed
- [ ] QueryClient configured with defaults
- [ ] QueryProvider wraps application
- [ ] React Query DevTools integrated
- [ ] API client created with type-safe methods
- [ ] API types defined matching backend
- [ ] useChannels hook functional
- [ ] useChannel hook functional
- [ ] useCreateChannel mutation functional
- [ ] useUpdateChannel mutation functional
- [ ] useDeleteChannel mutation functional
- [ ] useMedia hook functional
- [ ] useMediaItem hook functional
- [ ] useScanMedia mutation functional
- [ ] Query keys follow best practices
- [ ] Error handling works correctly
- [ ] Toast notifications on mutations
- [ ] Environment variables configured
- [ ] API test page created
- [ ] No TypeScript errors

### Definition of Done
- All acceptance criteria met
- API client successfully communicates with backend
- All hooks and mutations work correctly
- Type safety is maintained throughout
- Error handling provides good UX
- Code follows TanStack Query best practices

## Files Modified

### New Files Created
- `lib/types/api.ts` - TypeScript types for API
- `lib/api/client.ts` - API client class
- `lib/query/client.ts` - QueryClient configuration
- `components/providers/query-provider.tsx` - Query provider component
- `hooks/use-channels.ts` - Channel query hooks
- `hooks/use-media.ts` - Media query hooks
- `app/api-test/page.tsx` - API testing page
- `.env.local` - Environment variables (gitignored)
- `.env.example` - Environment variable template

### Files Modified
- `app/layout.tsx` - Added QueryProvider
- `package.json` - Added TanStack Query dependencies
- `.gitignore` - Ensure .env.local is ignored

## Notes

- TanStack Query v5 renamed `cacheTime` to `gcTime`
- Query keys follow hierarchical structure for better cache management
- DevTools are only included in development builds
- API client uses native fetch API (no axios needed)
- Error handling integrates with sonner toast notifications
- Backend must be running on port 8080 for API calls to work
- This task creates the foundation for all future data fetching needs

